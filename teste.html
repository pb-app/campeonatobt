<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ranking Beach Tennis</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3B82F6">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Ranking BT">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        #installBanner {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #3B82F6;
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        #installBanner button {
            background-color: white;
            color: #3B82F6;
            border: none;
            padding: 6px 12px;
            margin-left: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        #installBanner button:hover {
            background-color: #e5e7eb;
        }

        /* Tema Beach Tennis: Gradiente de azul mar e areia */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #F4A460); /* Azul céu para areia */
            color: #1F2937;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Adiciona ícone de raquete como background sutil */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="%23FFD700" stroke-width="1" opacity="0.1"><path d="M12 2L2 12M22 12L12 22M2 2L22 22M22 2L2 22"/></svg>') repeat;
            z-index: -1;
        }

        /* Animação de fade-in */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        .animate-fade-in-sm {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Para esconder elementos */
        .hidden {
            display: none;
        }

        /* Melhorias no Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #E5E7EB;
        }
        ::-webkit-scrollbar-thumb {
            background: #9CA3AF;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }

        /* Cards modernos com sombra suave e bordas arredondadas */
        .card {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        /* Botões com tema beach: azul e amarelo */
        button.bg-blue-600 {
            background-color: #007BFF; /* Azul mar */
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-weight: bold;
            transition: transform 0.2s;
        }
        button.bg-blue-600:hover {
            background-color: #0056b3;
            transform: scale(1.05);
        }

        button.bg-yellow-500 {
            background-color: #FFD700; /* Amarelo sol */
            color: #1F2937;
        }
        button.bg-yellow-500:hover {
            background-color: #FFC107;
        }

        /* Ícones maiores e coloridos */
        svg {
            stroke: #FFD700; /* Amarelo para ícones */
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- Banner de instalação -->
    <div id="installBanner">
        Instale o aplicativo para ter acesso rápido na tela inicial!
        <button id="installBtn">Instalar</button>
    </div>

    <script>
        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('✅ Service Worker registrado com sucesso!'))
                .catch(err => console.log('❌ Erro ao registrar o Service Worker:', err));
        }

        // Banner de instalação PWA
        let deferredPrompt;
        const installBanner = document.getElementById('installBanner');
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault(); // impede o prompt automático
            deferredPrompt = e;
            installBanner.style.display = 'block'; // mostra o banner
        });

        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            deferredPrompt.prompt(); // mostra o prompt
            const { outcome } = await deferredPrompt.userChoice;
            if (outcome === 'accepted') {
                console.log('✅ Usuário aceitou instalar');
            } else {
                console.log('❌ Usuário recusou instalar');
            }
            deferredPrompt = null;
            installBanner.style.display = 'none';
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>

    <div id="app-container" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 flex-grow">

        <header class="flex flex-col sm:flex-row justify-between items-center mb-6 sm:mb-8 gap-4 bg-white p-4 rounded-xl shadow-md card">
            <h1 class="text-3xl sm:text-4xl font-bold text-blue-600 text-center sm:text-left flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 12M22 12L12 22M2 2L22 22M22 2L2 22"/></svg> <!-- Ícone de raquete -->
                Ranking Beach Tennis
            </h1>
            <div id="header-buttons" class="flex gap-3">
            </div>
        </header>

        <div id="loading-spinner" class="text-center py-20">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
            <p class="mt-4 text-gray-500">Carregando dados...</p>
        </div>

        <main id="main-content" class="hidden card">
        </main>

        <footer class="text-center mt-8 text-gray-500 text-sm card">
            <p>ID da Liga: <span id="user-id-footer">Conectando...</span></p>
            <p>App de Ranking v4.0.4 (Final)</p>
        </footer>

    </div>

    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 max-w-sm w-full mx-auto animate-fade-in-sm card">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-xl sm:text-2xl font-bold text-blue-600"></h3>
                <button id="modal-close-icon" class="text-gray-500 hover:text-gray-900 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="modal-message" class="text-gray-700 text-sm sm:text-base mb-6 max-h-60 overflow-y-auto"></div>
            <button
                id="modal-close-btn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg shadow-lg transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Entendi
            </button>
        </div>
    </div>

    <script type="module">
        // Importações do Firebase SDK
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            onSnapshot, 
            collection, 
            addDoc, 
            deleteDoc, 
            query,
            Timestamp,
            getDoc,
            writeBatch,
            runTransaction
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        /* =============================================================================
           Configuração do Firebase (Fornecida pelo usuário)
           ============================================================================= */
        const firebaseConfig = {
          apiKey: "AIzaSyDeS-rk8OJKhghv1djVucmR3-erOa-ppMY",
          authDomain: "campeonato-sortudo.firebaseapp.com",
          projectId: "campeonato-sortudo",
          storageBucket: "campeonato-sortudo.firebasestorage.app",
          messagingSenderId: "706083235199",
          appId: "1:706083235199:web:5eca6041bb817401ee264a"
        };

        // Inicialização do Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        setLogLevel('debug'); 

        /* =============================================================================
           ID Mestre e Senha de Admin
           ============================================================================= */
        const MESTRE_USER_ID = "campeonato-sortudo-admin";

        // ==========================================
        // === MUDE SUA SENHA DE ADMIN AQUI ===
        // ==========================================
        const ADMIN_PASSWORD = "adm2025"; 

        /* =============================================================================
           Estado Global do Aplicativo
           ============================================================================= */
        let appState = {
            userId: null, // Será preenchido com o MESTRE_USER_ID
            isAuthReady: false,
            isAdmin: false, 
            isTelaoMode: false,
            currentView: 'loading', // 'loading', 'login', 'championshipList', 'championshipView', 'globalRanking', 'telaoView'
            currentChampionshipId: null,
            currentRankingId: null, // ID do ranking sendo visualizado/editado
        };

        let allRankings = []; // Lista de todos os rankings (ex: [{id: 'geral', name: 'Ranking Geral'}])
        let championships = []; // Lista de todos os campeonatos
        let globalPlayers = []; // Lista de jogadores DO RANKING ATUALMENTE SELECIONADO (appState.currentRankingId)
        let activeChampionship = null; // Dados do campeonato selecionado

        // Listeners do Firebase (para poder "desligar" ao trocar de tela)
        let unsubscribeRankingsList = () => {}; 
        let unsubscribeChampionships = () => {}; 
        let unsubscribeGlobalPlayers = () => {}; 
        let unsubscribeActiveChampionship = () => {}; 

        /* =============================================================================
           Referências do DOM
           ============================================================================= */
        const appContainer = document.getElementById('app-container');
        const mainContent = document.getElementById('main-content');
        const loadingSpinner = document.getElementById('loading-spinner');
        const headerButtons = document.getElementById('header-buttons');
        const userIdFooter = document.getElementById('user-id-footer');

        // Modal
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalCloseIcon = document.getElementById('modal-close-icon');

        /* =============================================================================
           Constantes de Pontuação (Padrão)
           ============================================================================= */
        // Usado como fallback e valores padrão dos inputs
        const DEFAULT_RANKING_POINTS = {
            GOLD_WINNER: 100,
            GOLD_RUNNERUP: 70,
            SILVER_WINNER: 40,
            SILVER_RUNNERUP: 20,
            PARTICIPATION: 5
        };

        /* =============================================================================
           Ícones SVG (Reutilizados) - Adicionados mais ícones temáticos
           ============================================================================= */
        const icons = {
            users: '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>',
            plus: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
            trash: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>',
            swords: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"></polyline><line x1="13" y1="19" x2="19" y2="13"></line><line x1="16" y1="16" x2="20" y2="20"></line><line x1="19" y1="21" x2="21" y2="19"></polyline><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5"></polyline><line x1="11" y1="5" x2="5" y2="11"></line><line x1="8" y1="8" x2="4" y2="4"></line><line x1="3" y1="5" x2="5" y2="3"></line></svg>',
            trophy: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></svg>',
            shield: '<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block text-yellow-500"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>',
            shieldOff: '<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block text-gray-500"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><line x1="2" y1="2" x2="22" y2="22"></line></svg>',
            medal: '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-3 text-white"><path d="M12 16.5l4-2.3 4 2.3-1.5-4.6 3.5-3.4-4.6-.7-2-4.2-2 4.2-4.6.7 3.5 3.4L8 16.5z"></path><path d="M12 15l-4-2.3V7.9l4 2.3 4-2.3v4.8L12 15z"></path></svg>', 
            award: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 17 17 23 15.79 13.88"></polyline></svg>',
            arrowLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>',
            eye: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>',
            logIn: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line></svg>',
            logOut: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>',
            check: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>',
            settings: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>',
            shovel: '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-3 text-red-600"><path d="M2 22v-5l5-5 5 5v5H2z"></path><path d="M9.5 17H14a5 5 0 0 0 5-5V7A2 2 0 0 0 17 5H7a2 2 0 0 0-2 2v5a5 5 0 0 0 5 5z"></path><path d="M9.5 17v5"></path></svg>', 
            shovelSmall: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 22v-5l5-5 5 5v5H2z"></path><path d="M9.5 17H14a5 5 0 0 0 5-5V7A2 2 0 0 0 17 5H7a2 2 0 0 0-2 2v5a5 5 0 0 0 5 5z"></path><path d="M9.5 17v5"></path></svg>',
            printer: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></svg>',
            fileDown: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
            tv: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline></svg>'
        };

        /* =============================================================================
           Funções do Modal
           ============================================================================= */
        const showModal = (title, message) => {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; 
            modal.classList.remove('hidden');
        };
        const hideModal = () => modal.classList.add('hidden');
        modalCloseBtn.addEventListener('click', hideModal);
        modalCloseIcon.addEventListener('click', hideModal);
        modal.addEventListener('click', hideModal);
        modal.firstElementChild.addEventListener('click', (e) => e.stopPropagation());

        /* =============================================================================
           Funções de Navegação e Renderização Principal
           ============================================================================= */

        // Router Principal
        const render = () => {

            // Esconde o spinner global se não estivermos na tela de loading
            if (appState.currentView !== 'loading') {
                loadingSpinner.classList.add('hidden');
                mainContent.classList.remove('hidden');
            } else {
                loadingSpinner.classList.remove('hidden');
                mainContent.classList.add('hidden');
                return;
            }

            // Não renderiza cabeçalho no Modo Telão
            if (!appState.isTelaoMode) {
                renderHeaderButtons();
            }

            // Renderiza o conteúdo principal baseado na view
            switch (appState.currentView) {
                case 'login': 
                    renderLogin();
                    break;
                case 'championshipList':
                    renderChampionshipList();
                    break;
                case 'globalRanking':
                    renderGlobalRanking();
                    break;
                case 'championshipView':
                    renderChampionshipView();
                    break;
                case 'telaoView':
                    renderTelaoView();
                    break;
                default:
                    mainContent.innerHTML = `<p>Estado desconhecido: ${appState.currentView}</p>`;
            }
        };

        const navigateTo = (view, champId = null) => {
            if (view === 'login') {
                appState.isAdmin = false;
            }

            appState.currentView = view;
            appState.currentChampionshipId = champId;

            // Desliga listeners antigos
            unsubscribeActiveChampionship();
            activeChampionship = null;

            // Se estamos abrindo um campeonato OU um telão, precisamos garantir
            // que o listener global de players esteja olhando o ranking *correto*.
            if ((view === 'championshipView' || view === 'telaoView') && champId) {
                const champ = championships.find(c => c.id === champId);
                if (champ && champ.rankingId) {
                    // Se o ranking do app não for o do camp, troca e re-escuta
                    if (appState.currentRankingId !== champ.rankingId) {
                        appState.currentRankingId = champ.rankingId;
                        listenToGlobalPlayers(); // Isso vai carregar globalPlayers com a lista certa
                    }
                } else if (championships.length > 0 && !champ) {
                    // Pode acontecer se os listeners não estiverem prontos
                    console.warn("Navegando para o telão, mas a lista de campeonatos ainda não tem o ID:", champId);
                    // Tentaremos carregar mesmo assim.
                }
                listenToActiveChampionship(champId); // Isso vai carregar o camp e chamar o render()

            } else if (view === 'globalRanking') {
                // Garante que o listener de players está ligado ao ranking selecionado
                listenToGlobalPlayers();
                render();
            } else {
                // Para outras telas (login, champList), renderiza imediatamente
                render();
            }
        };

        const renderHeaderButtons = () => {
            let navHtml = ''; // Botões de Navegação (Voltar/Ranking)
            let authHtml = ''; // Botões de Autenticação (Login/Sair)

            // Lógica de Navegação
            if (appState.currentView === 'championshipList') {
                navHtml = `
                <button
                    id="nav-to-ranking"
                    class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg shadow-sm transition-all flex items-center justify-center gap-2 text-sm">
                    ${icons.award}
                    Ranking Geral
                </button>
                `;
            } else if (appState.currentView === 'globalRanking' || appState.currentView === 'championshipView') {
                navHtml = `
                <button
                    id="nav-to-list"
                    class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg shadow-sm transition-all flex items-center justify-center gap-2 text-sm">
                    ${icons.arrowLeft}
                    Voltar
                </button>
                `;
            }

            // Lógica de Autenticação
            if (appState.currentView !== 'login') {
                if (appState.isAdmin) {
                    authHtml = `
                    <button
                        id="nav-to-login"
                        class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-sm transition-all flex items-center justify-center gap-2 text-sm">
                        ${icons.logOut}
                        Sair (Admin)
                    </button>
                    `;
                } else {
                    authHtml = `
                    <button
                        id="nav-to-login"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-sm transition-all flex items-center justify-center gap-2 text-sm">
                        ${icons.logIn}
                        Login (Admin)
                    </button>
                    `;
                }
            }

            headerButtons.innerHTML = navHtml + authHtml; // Concatena os botões

            // Adiciona listeners aos botões
            const rankingBtn = document.getElementById('nav-to-ranking');
            if (rankingBtn) rankingBtn.addEventListener('click', () => navigateTo('globalRanking'));

            const listBtn = document.getElementById('nav-to-list');
            if (listBtn) listBtn.addEventListener('click', () => navigateTo('championshipList'));

            const loginBtn = document.getElementById('nav-to-login');
            if (loginBtn) loginBtn.addEventListener('click', () => navigateTo('login'));
        };

        /* =============================================================================
           TELA 0: Login
           ============================================================================= */

        const renderLogin = () => {
            mainContent.innerHTML = `
                <div class="card animate-fade-in">
                    <h2 class="text-3xl font-bold text-center text-blue-600 mb-8">Bem-vindo(a)</h2>
                    
                    <div class="space-y-4">
                        <button
                            id="visitor-login-btn"
                            class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-4 px-6 rounded-lg shadow-sm transition-all flex items-center justify-center gap-3 text-lg">
                            ${icons.eye}
                            Modo Visitante
                        </button>
                        
                        <button
                            id="admin-login-btn"
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-6 rounded-lg shadow-lg transition-all flex items-center justify-center gap-3 text-lg">
                            ${icons.logIn}
                            Modo Administrador
                        </button>
                    </div>
                </div>
            `;

            // Listeners
            document.getElementById('visitor-login-btn').addEventListener('click', () => {
                appState.isAdmin = false;
                navigateTo('championshipList');
            });

            document.getElementById('admin-login-btn').addEventListener('click', () => {
                const password = prompt("Digite a senha de administrador:");
                if (password === ADMIN_PASSWORD) {
                    appState.isAdmin = true;
                    navigateTo('championshipList');
                } else if (password !== null) { // Só mostra erro se o usuário não clicou em "Cancelar"
                    showModal("Acesso Negado", "Senha incorreta.");
                }
            });
        };

        /* =============================================================================
           TELA 1: Lista de Campeonatos (Histórico)
           ============================================================================= */

        const renderChampionshipList = () => {
            const sortedChampionships = [...championships].sort((a, b) => b.createdAt - a.createdAt);

            const championshipsListHtml = sortedChampionships.length === 0
                ? `<p class="text-gray-500 text-center py-4">Nenhum campeonato cadastrado.</p>`
                : sortedChampionships.map(champ => {
                    let statusColor = 'text-yellow-600';
                    let statusText = 'Em andamento';
                    if (champ.status === 'registration') { statusColor = 'text-blue-600'; statusText = 'Em Inscrição'; }
                    if (champ.status === 'finished') { statusColor = 'text-green-600'; statusText = 'Finalizado'; }

                    const ranking = allRankings.find(r => r.id === champ.rankingId);
                    const rankingHtml = ranking ? `<span class="block text-xs text-yellow-600">${ranking.name}</span>` : '';

                    const deleteButtonHtml = appState.isAdmin ? `
                    <button
                        class="delete-champ-btn text-red-600 hover:text-red-700 transition-colors p-2 rounded-lg bg-gray-100"
                        data-id="${champ.id}">
                        ${icons.trash}
                    </button>` : '';

                    return `
                    <div class="flex flex-col sm:flex-row justify-between items-center bg-white border border-gray-200 p-4 rounded-xl shadow-sm animate-fade-in-sm gap-3 card">
                        <div>
                            <span class="text-gray-800 font-bold text-lg">${champ.name}</span>
                            <span class="block text-sm ${statusColor}">${statusText}</span>
                            ${rankingHtml}
                            <span class="block text-xs text-gray-500">${new Date(champ.createdAt?.toDate()).toLocaleDateString()}</span>
                        </div>
                        <div class="flex gap-2">
                             <button
                                class="open-champ-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all flex items-center gap-2 text-sm"
                                data-id="${champ.id}">
                                ${icons.eye} Ver
                            </button>
                            ${deleteButtonHtml}
                        </div>
                    </div>
                    `}).join('');

            const rankingsOptions = allRankings.map(r => `<option value="${r.id}">${r.name}</option>`).join('');

            const newChampionshipFormHtml = appState.isAdmin ? `
            <form id="add-championship-form">
                <div class="card mb-8">
                    <h2 class="text-2xl font-bold text-blue-600 mb-4">Novo Campeonato</h2>
                    
                    <div class="mb-4">
                        <label for="championship-name-input" class="block text-sm font-medium text-gray-700 mb-1">Nome do Campeonato</label>
                        <input
                            type="text"
                            id="championship-name-input"
                            placeholder="ex: Torneio de Verão"
                            class="w-full bg-gray-50 border border-gray-300 text-gray-800 rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            required
                        />
                    </div>
                    
                    <div class="mb-4">
                        <label for="ranking-select" class="block text-sm font-medium text-gray-700 mb-1">Vincular ao Ranking</label>
                        <div class="flex gap-2">
                            <select id="ranking-select" class="w-full bg-gray-50 border border-gray-300 text-gray-800 rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                                ${rankingsOptions.length > 0 ? rankingsOptions : '<option disabled>Nenhum ranking encontrado...</option>'}
                            </select>
                            <button type="button" id="add-new-ranking-btn" class="flex-shrink-0 bg-blue-600 hover:bg-blue-700 text-white font-bold p-3 rounded-lg shadow-md transition-all">
                                ${icons.plus}
                            </button>
                        </div>
                    </div>


                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Configuração de Pontos</h3>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-3 mb-4">
                        <div>
                            <label for="points-gold-winner" class="block text-xs font-medium text-green-600 mb-1">Campeão Ouro</label>
                            <input type="number" id="points-gold-winner" min="0" value="${DEFAULT_RANKING_POINTS.GOLD_WINNER}"
                                   class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2 text-center text-gray-800">
                        </div>
                        <div>
                            <label for="points-gold-runnerup" class="block text-xs font-medium text-green-700 mb-1">Vice Ouro</label>
                            <input type="number" id="points-gold-runnerup" min="0" value="${DEFAULT_RANKING_POINTS.GOLD_RUNNERUP}"
                                   class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2 text-center text-gray-800">
                        </div>
                        <div>
                            <label for="points-silver-winner" class="block text-xs font-medium text-gray-600 mb-1">Campeão Prata</label>
                            <input type="number" id="points-silver-winner" min="0" value="${DEFAULT_RANKING_POINTS.SILVER_WINNER}"
                                   class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2 text-center text-gray-800">
                        </div>
                        <div>
                            <label for="points-silver-runnerup" class="block text-xs font-medium text-gray-700 mb-1">Vice Prata</label>
                            <input type="number" id="points-silver-runnerup" min="0" value="${DEFAULT_RANKING_POINTS.SILVER_RUNNERUP}"
                                   class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2 text-center text-gray-800">
                        </div>
                        <div>
                            <label for="points-participation" class="block text-xs font-medium text-gray-500 mb-1">Participação</label>
                            <input type="number" id="points-participation" min="0" value="${DEFAULT_RANKING_POINTS.PARTICIPATION}"
                                   class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2 text-center text-gray-800">
                        </div>
                    </div>

                    <button
                        type="submit"
                        id="add-championship-btn"
                        class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-5 rounded-lg shadow-lg transition-all flex items-center justify-center gap-2 disabled:opacity-50">
                        ${icons.plus}
                        <span>Criar Campeonato</span>
                    </button>
                </div>
            </form>
            ` : ''; // Se não for admin, não mostra nada

            mainContent.innerHTML = `
                <div class="animate-fade-in">
                    ${newChampionshipFormHtml}

                    <div class="card">
                        <h3 class="text-2xl font-bold mb-5 text-blue-600">Histórico de Campeonatos</h3>
                        <div class="max-h-[60vh] overflow-y-auto pr-2 space-y-3">
                            ${championshipsListHtml}
                        </div>
                    </div>
                </div>
            `;

            // Listeners (só adiciona se o elemento existir)
            if (appState.isAdmin) {
                const addForm = document.getElementById('add-championship-form');
                if (addForm) addForm.addEventListener('submit', handleAddChampionship);

                // NOVO: Listener para criar ranking
                const addRankingBtn = document.getElementById('add-new-ranking-btn');
                if (addRankingBtn) addRankingBtn.addEventListener('click', handleAddNewRanking);

                document.querySelectorAll('.delete-champ-btn').forEach(btn => {
                    btn.addEventListener('click', () => handleDeleteChampionship(btn.dataset.id));
                });
            }

            document.querySelectorAll('.open-champ-btn').forEach(btn => {
                btn.addEventListener('click', () => navigateTo('championshipView', btn.dataset.id));
            });
        };

        const handleAddChampionship = async (e) => {
            e.preventDefault();
            // Esta função só é chamada se o formulário existir (isAdmin = true)
            const input = document.getElementById('championship-name-input');
            const button = document.getElementById('add-championship-btn');
            const champName = input.value.trim();
            if (!champName) return;

            // =================================================================
            // === MUDANÇA (REQUEST 3): Pega o ID do ranking selecionado ===
            // =================================================================
            const rankingId = document.getElementById('ranking-select').value;
            if (!rankingId) {
                showModal("Erro", "Nenhum ranking foi selecionado. Crie um ranking primeiro.");
                return;
            }

            button.disabled = true;
            button.lastChild.textContent = "Criando...";

            // Coleta os pontos personalizados
            const pointsConfig = {
                goldWinner: parseInt(document.getElementById('points-gold-winner').value) || 0,
                goldRunnerUp: parseInt(document.getElementById('points-gold-runnerup').value) || 0,
                silverWinner: parseInt(document.getElementById('points-silver-winner').value) || 0,
                silverRunnerUp: parseInt(document.getElementById('points-silver-runnerup').value) || 0,
                participation: parseInt(document.getElementById('points-participation').value) || 0
            };

            try {
                const batch = writeBatch(db);

                // 1. Cria a referência para o NOVO doc de campeonato
                const champCollectionRef = collection(db, 'users', appState.userId, 'championships');
                const newChampRef = doc(champCollectionRef);

                // 2. Cria a referência para o doc de dados aninhado
                const champDataRef = doc(db, 'users', appState.userId, 'championships', newChampRef.id, 'data', 'main');

                // 3. Adiciona os dados ao batch
                batch.set(newChampRef, {
                    name: champName,
                    createdAt: Timestamp.now(),
                    status: 'registration',
                    winnerGold: null,
                    winnerSilver: null,
                    pointsConfig: pointsConfig, // Salva os pontos personalizados
                    rankingId: rankingId // NOVO: Salva o ID do ranking
                });

                batch.set(champDataRef, {
                    players: [],
                    groups: [],
                    goldBracket: [],
                    silverBracket: [],
                    status: 'registration'
                });

                // 4. Executa o batch
                await batch.commit();

                input.value = '';
                showModal("Sucesso!", `Campeonato "${champName}" criado e vinculado ao ranking.`);
            } catch (error) {
                console.error("Erro ao criar campeonato:", error);
                showModal("Erro", "Não foi possível criar o campeonato.");
            }

            button.disabled = false;
            button.lastChild.textContent = "Criar Campeonato";
        };

        const handleDeleteChampionship = async (champId) => {
            // Esta função só é chamada se o botão existir (isAdmin = true)
            const champ = championships.find(c => c.id === champId);
            if (window.prompt(`Para confirmar, digite o nome do campeonato: "${champ.name}"`) !== champ.name) {
                showModal("Cancelado", "A exclusão foi cancelada.");
                return;
            }

            try {
                // Deleta o documento de dados
                await deleteDoc(doc(db, 'users', appState.userId, 'championships', champId, 'data', 'main'));
                // Deleta o documento principal
                await deleteDoc(doc(db, 'users', appState.userId, 'championships', champId));
            } catch (error) {
                console.error("Erro ao excluir campeonato:", error);
                showModal("Erro", "Não foi possível excluir o campeonato.");
            }
        };

        // =================================================================
        // === NOVA FUNÇÃO: Para criar um novo ranking (temporada, etc)
        // =================================================================
        const handleAddNewRanking = async () => {
            const name = prompt("Nome do novo ranking (ex: Temporada 2025):");
            if (!name || name.trim() === '') return;

            // Cria um ID seguro para o banco de dados
            const id = name.trim().toLowerCase()
                .replace(/\s+/g, '-') // substitui espaços por -
                .replace(/[^a-z0-9-]/g, ''); // remove caracteres não-alfanuméricos (exceto -)

            if (!id) {
                showModal("Erro", "Nome inválido. Use letras e números.");
                return;
            }

            // Verifica se o ID ou Nome já existem
            if (allRankings.find(r => r.id === id || r.name.toLowerCase() === name.trim().toLowerCase())) {
                showModal("Erro", "Um ranking com esse nome ou ID já existe.");
                return;
            }

            const newRanking = { id, name: name.trim() };
            const newList = [...allRankings, newRanking];

            try {
                // Salva a lista atualizada no documento 'rankings'
                await setDoc(doc(db, 'users', appState.userId, 'app_data', 'rankings'), { list: newList });
                showModal("Sucesso!", `Ranking "${name.trim()}" foi criado.`);
                // O listener 'listenToRankingsList' vai atualizar a UI automaticamente
            } catch (error) {
                console.error("Erro ao criar ranking:", error);
                showModal("Erro", "Não foi possível salvar o novo ranking.");
            }
        };

        /* =============================================================================
           TELA 2: Ranking Global
           ============================================================================= */

        const renderGlobalRanking = () => {
            const sortedPlayers = [...globalPlayers].sort((a, b) => b.points - a.points);

            const rankingsHtml = sortedPlayers.length === 0
                ? `<tr><td colspan="6" class="p-4 text-center text-gray-500">Nenhum jogador neste ranking.</td></tr>`
                : sortedPlayers.map((player, index) => `
                    <tr class="border-b border-gray-100 animate-fade-in-sm">
                        <td class="p-3 sm:p-4 font-bold text-lg text-blue-600">${index + 1}º</td>
                        <td class="p-3 sm:p-4 font-medium text-gray-800">${player.name}</td>
                        <td class="p-3 sm:p-4 font-bold text-xl text-yellow-600">${player.points || 0}</td>
                        <td class="p-3 sm:p-4 text-center text-green-600">${player.goldWins || 0}</td>
                        <td class="p-3 sm:p-4 text-center text-gray-600">${player.silverWins || 0}</td>
                        <td class="p-3 sm:p-4 text-center text-red-600">${player.coveiroWins || 0}</td>
                    </tr>
                `).join('');

            const rankingsOptions = allRankings.map(r => 
                `<option value="${r.id}" ${r.id === appState.currentRankingId ? 'selected' : ''}>
                    ${r.name}
                </option>`
            ).join('');

            const manageButtonHtml = appState.isAdmin ? `
                <button id="manage-rankings-btn" class="flex-shrink-0 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold p-3 rounded-lg shadow-sm transition-all" title="Gerenciar Rankings">
                    ${icons.settings}
                </button>
            ` : '';

            // Botão Gerar PDF
            const printButtonHtml = `
                <button id="print-ranking-pdf-btn" class="flex-shrink-0 bg-red-600 hover:bg-red-700 text-white font-bold p-3 rounded-lg shadow-sm transition-all" title="Gerar PDF do Ranking">
                    ${icons.fileDown}
                </button>
            `;

            const rankingSelectorHtml = `
                <div class="mb-6">
                    <label for="ranking-view-select" class="block text-sm font-medium text-gray-700 mb-1">Visualizando Ranking:</label>
                    <div class="flex gap-2">
                        <select id="ranking-view-select" class="w-full bg-white border border-gray-300 text-gray-800 rounded-lg p-3 shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            ${rankingsOptions.length > 0 ? rankingsOptions : '<option disabled>Nenhum ranking...</option>'}
                        </select>
                        ${manageButtonHtml}
                        ${printButtonHtml}
                    </div>
                </div>
            `;

            mainContent.innerHTML = `
                <div class="card animate-fade-in">
                    <h2 class="text-3xl font-bold mb-6 text-blue-600 flex items-center gap-3">
                        ${icons.award} Ranking Geral
                    </h2>
                    
                    ${rankingSelectorHtml}

                    <div class="overflow-x-auto">
                        <table class="w-full min-w-max text-left">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="p-3 sm:p-4 rounded-tl-lg text-gray-600">Pos.</th>
                                    <th class="p-3 sm:p-4 text-gray-600">Jogador</th>
                                    <th class="p-3 sm:p-4 text-gray-600">Pontos</th>
                                    <th class="p-3 sm:p-4 text-center text-gray-600">${icons.trophy} Ouro</th>
                                    <th class="p-3 sm:p-4 text-center text-gray-600">${icons.trophy} Prata</th>
                                    <th class="p-3 sm:p-4 text-center rounded-tr-lg text-gray-600">${icons.shovelSmall} Coveiro</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
                                ${rankingsHtml}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            const rankingViewSelect = document.getElementById('ranking-view-select');
            if (rankingViewSelect) rankingViewSelect.addEventListener('change', handleViewRankingChange);

            const manageRankingsBtn = document.getElementById('manage-rankings-btn');
            if (manageRankingsBtn) manageRankingsBtn.addEventListener('click', renderRankingManagementModal);

            const printRankingBtn = document.getElementById('print-ranking-pdf-btn');
            if (printRankingBtn) printRankingBtn.addEventListener('click', handlePrintRankingPDF);
        };

        const renderRankingManagementModal = () => {
            const rankingsHtml = allRankings.map(r => {
                const inUse = championships.find(c => c.rankingId === r.id);
                const deleteBtn = inUse ? 
                    `<span class="text-xs text-gray-500" title="Em uso pelo camp: ${inUse.name}">Em uso</span>` :
                    `<button class="delete-ranking-btn text-red-600 hover:text-red-700" data-id="${r.id}" data-name="${r.name}">${icons.trash}</button>`;

                return `
                <div class="flex justify-between items-center bg-gray-100 p-3 rounded-lg">
                    <span class="text-gray-800 font-medium">${r.name}</span>
                    ${deleteBtn}
                </div>
                `;
            }).join('');

            const modalContent = `
                <p class="text-sm text-gray-500 mb-4">Você só pode excluir rankings que não estão sendo usados por nenhum campeonato.</p>
                <div class="space-y-2">
                    ${rankingsHtml.length > 0 ? rankingsHtml : '<p>Nenhum ranking criado.</p>'}
                </div>
            `;

            showModal("Gerenciar Rankings", modalContent);

            document.querySelectorAll('.delete-ranking-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.currentTarget.dataset.id;
                    const name = e.currentTarget.dataset.name;
                    handleDeleteRanking(id, name);
                });
            });
        };

        const handleDeleteRanking = async (rankingId, rankingName) => {
            if (!confirm(`Tem certeza que deseja excluir o ranking "${rankingName}"? Esta ação não pode ser desfeita.`)) {
                return;
            }

            const inUse = championships.find(c => c.rankingId === rankingId);
            if (inUse) {
                showModal("Erro", `Não é possível excluir. Este ranking está em uso pelo campeonato "${inUse.name}".`);
                return;
            }

            const newList = allRankings.filter(r => r.id !== rankingId);

            try {
                await setDoc(doc(db, 'users', appState.userId, 'app_data', 'rankings'), { list: newList });
                hideModal();
            } catch (error) {
                console.error("Erro ao excluir ranking:", error);
                showModal("Erro", "Não foi possível excluir o ranking.");
            }
        };


        const handleViewRankingChange = (e) => {
            const newRankingId = e.target.value;
            appState.currentRankingId = newRankingId;
            globalPlayers = []; 

            render(); 
            listenToGlobalPlayers();
        };

        /* =============================================================================
           TELA 3: Visão do Campeonato (ADMIN)
           ============================================================================= */

        // Função "Router" da tela do campeonato (ADMIN)
        const renderChampionshipView = () => {
            if (!activeChampionship) {
                mainContent.innerHTML = `
                <div class="text-center py-20 animate-fade-in">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mx-auto"></div>
                    <p class="mt-4 text-gray-500">Carregando campeonato...</p>
                </div>
                `;
                return;
            }

            let html = '';
            const champInfo = championships.find(c => c.id === appState.currentChampionshipId);

            // Botões PDF (se finalizado) e Telão (sempre)
            let topButtonsHtml = '';
            if (appState.isAdmin) { // Só admin vê esses botões
                let pdfButtonHtml = '';
                if (champInfo?.status === 'finished') {
                    pdfButtonHtml = `
                        <button id="print-champ-pdf-btn" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg ...(truncated 39115 characters)...artas de Final'
                    : `Rodada ${roundNum}`;

                const matchesHtml = rounds[roundNum].map(match => {
                    const pair1 = match.pairs[0]; 
                    const pair2 = match.pairs[1]; 
                    const isPair1Winner = match.winner && pair1 && match.winner.id === pair1.id;
                    const isPair2Winner = match.winner && pair2 && match.winner.id === pair2.id;
                    const score1 = match.score[0];
                    const score2 = match.score[1];

                    const winnerClass1 = isPair1Winner ? 'text-green-600 font-bold' : 'text-gray-800';
                    const winnerClass2 = isPair2Winner ? 'text-green-600 font-bold' : 'text-gray-800';

                    return `
                    <div class="bg-gray-100 rounded-lg shadow-sm border border-gray-200 p-4">
                        <div class="flex justify-between items-center mb-2">
                            <span class="font-medium text-lg ${winnerClass1}">
                                ${pair1 ? pair1.name : 'Aguardando...'}
                            </span>
                            <span class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-xl font-bold opacity-70">
                                ${score1 === null ? '-' : score1}
                            </span>
                        </div>
                        
                        <div class="flex items-center my-2">
                            <div class="flex-grow border-t border-gray-300"></div>
                            <span class="mx-2 text-sm text-gray-500">vs</span>
                            <div class="flex-grow border-t border-gray-300"></div>
                        </div>

                        <div class="flex justify-between items-center">
                            <span class="font-medium text-lg ${winnerClass2}">
                                ${pair2 ? pair2.name : 'Aguardando...'}
                            </span>
                            <span class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-xl font-bold opacity-70">
                                ${score2 === null ? '-' : score2}
                            </span>
                        </div>
                    </div>
                    `;
                }).join('');

                return `
                <div class="flex flex-col space-y-6 w-full max-w-xs">
                    <h4 class="text-xl font-semibold text-gray-800">${roundTitle}</h4>
                    ${matchesHtml}
                </div>
                `;
            }).join('');

            // Removido o ícone do título principal
            return `
            <div class="card p-4 sm:p-6 mb-8 w-full sm:max-w-sm">
                <h3 class="text-3xl font-bold mb-6 text-blue-600">
                    ${title}
                </h3>
                ${championHtml}
                <div class="flex flex-wrap justify-center gap-4 sm:gap-6 pb-4">
                    ${roundsHtml}
                </div>
            </div>
            `;
        };


        /* =============================================================================
           Lógica do Campeonato Ativo (Ações de Admin)
           ============================================================================= */

        // (ADMIN) -- Abrir o Telão
        const handleLaunchTelao = () => {
            const champId = appState.currentChampionshipId;
            if (!champId) {
                showModal("Erro", "ID do campeonato não encontrado.");
                return;
            }

            // Constrói a URL para o modo telão
            const url = `${window.location.origin}${window.location.pathname}?telao=true&champId=${champId}`;

            // Abre em uma nova aba
            window.open(url, '_blank');
        };

        const handleAddNewPlayerToChampionship = async (e) => {
            e.preventDefault();
            const input = document.getElementById('new-player-name-input');
            const button = document.getElementById('add-new-player-btn');
            const playerName = input.value.trim();
            if (!playerName) return;

            // 1. VERIFICA DUPLICIDADE NO RANKING (OPCIONAL, JÁ FEITO)
            const existingPlayerInRanking = globalPlayers.find(p => p.name.toLowerCase() === playerName.toLowerCase());
            if (existingPlayerInRanking) {
                showModal("Jogador Já Existe", `Um jogador chamado "${playerName}" já existe no ranking. Use o menu "Adicionar do Ranking" para adicioná-lo.`);
                return;
            }

            // 2. VERIFICA DUPLICIDADE NO TORNEIO ATUAL (NOVO REQUISITO)
            const alreadyInTournament = activeChampionship.players.some(
                p => p.name.toLowerCase() === playerName.toLowerCase()
            );
            if (alreadyInTournament) {
                showModal("Duplicidade Detectada", `O jogador "${playerName}" já está inscrito neste torneio.`);
                return;
            }

            button.disabled = true;

            const newPlayer = {
                id: crypto.randomUUID(), // Novo ID, pois é um novo jogador
                name: playerName
            };

            const newChampData = {
                ...activeChampionship,
                players: [...activeChampionship.players, newPlayer]
            };

            await saveActiveChampionship(newChampData);

            input.value = '';
            button.disabled = false;
        };

        const handleAddExistingPlayerToChampionship = async (e) => {
            e.preventDefault();
            const select = document.getElementById('existing-player-select');
            const button = document.getElementById('add-existing-player-btn');
            const playerId = select.value;

            if (!playerId) {
                showModal("Erro", "Nenhum jogador selecionado.");
                return;
            }

            const player = globalPlayers.find(p => p.id === playerId);
            if (!player) {
                showModal("Erro", "Jogador não encontrado. Tente atualizar a página.");
                return;
            }

            // NOVO REQUISITO: Verifica se o ID já está no torneio
            const alreadyInTournament = activeChampionship.players.some(
                p => p.id === playerId
            );
            if (alreadyInTournament) {
                showModal("Duplicidade Detectada", `O jogador "${player.name}" já está inscrito neste torneio.`);
                return;
            }


            button.disabled = true;

            const newChampData = {
                ...activeChampionship,
                players: [...activeChampionship.players, { id: player.id, name: player.name }]
            };

            await saveActiveChampionship(newChampData);

            button.disabled = false;
        };

        const handleDeletePlayerFromChampionship = async (playerId) => {
            if (!confirm("Tem certeza que deseja remover este jogador DO TORNEIO?")) return;

            const newChampData = {
                ...activeChampionship,
                players: activeChampionship.players.filter(p => p.id !== playerId)
            };
            await saveActiveChampionship(newChampData);
        };

        const handleGenerateChampionship = async () => {
            const playerCount = activeChampionship.players.length;
            const isMultypleOfFour = playerCount % 4 === 0;

            if (playerCount < 4 || !isMultypleOfFour) {
                showModal("Número de Jogadores Inválido", `O campeonato requer um número de jogadores múltiplo de 4 para grupos de 4 (ex: 4, 8, 12...). Você tem ${playerCount}.`);
                return;
            }
            // Verifica se o número de duplas para o mata-mata será uma potência de 2
            const numDuplas = (playerCount / 4) * 2; // (jogadores/4 grupos) * 2 duplas por grupo
            if (![2, 4, 8, 16, 32].includes(numDuplas)) {
                 showModal("Regra da Chave", `A regra atual de mata-mata só suporta 2, 4, 8, 16 ou 32 duplas. Você terá ${numDuplas} duplas. Por favor, ajuste o número de jogadores.`);
                 return;
            }


            if (!confirm(`Iniciar grupos com ${playerCount} jogadores? Isso criará ${playerCount / 4} grupos.`)) {
                return;
            }

            try {
                const shuffledPlayers = [...activeChampionship.players].sort(() => 0.5 - Math.random());
                const newGroups = [];

                for (let i = 0; i < shuffledPlayers.length; i += 4) {
                    const groupPlayers = shuffledPlayers.slice(i, i + 4);
                    const [p1, p2, p3, p4] = groupPlayers;

                    newGroups.push({
                        id: `group_${i / 4 + 1}`,
                        players: groupPlayers,
                        matches: [
                            { id: 1, p: [p1.id, p2.id, p3.id, p4.id], names: [`${p1.name} / ${p2.name}`, `${p3.name} / ${p4.name}`], score: [null, null] },
                            { id: 2, p: [p1.id, p3.id, p2.id, p4.id], names: [`${p1.name} / ${p3.name}`, `${p2.name} / ${p4.name}`], score: [null, null] },
                            { id: 3, p: [p1.id, p4.id, p2.id, p3.id], names: [`${p1.name} / ${p4.name}`, `${p2.name} / ${p3.name}`], score: [null, null] },
                        ]
                    });
                }

                const newChampData = {
                    ...activeChampionship,
                    status: 'groups',
                    groups: newGroups
                };
                await saveActiveChampionship(newChampData);

                // Atualiza o status principal do campeonato (para a lista)
                const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                await setDoc(champRef, { status: 'groups' }, { merge: true });

            } catch (error) {
                console.error("Erro ao gerar campeonato:", error);
                showModal("Erro", "Não foi possível gerar os grupos.");
            }
        };

        const handleConfirmGroupScore = (groupIndex, matchIndex) => {
            const val0 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s0`).value;
            const val1 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s1`).value;

            const score0 = val0 === '' ? null : parseInt(val0, 10);
            const score1 = val1 === '' ? null : parseInt(val1, 10);

            if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                showModal("Placar Inválido", "Ambos os placares devem ser preenchidos com números positivos (ou 0).");
                return;
            }

            const newChampData = JSON.parse(JSON.stringify(activeChampionship));
            newChampData.groups[groupIndex].matches[matchIndex].score[0] = score0;
            newChampData.groups[groupIndex].matches[matchIndex].score[1] = score1;

            saveActiveChampionship(newChampData); 
        };

        const handlePrintGroup = (groupIndex) => {
            const group = activeChampionship.groups[groupIndex];
            const champ = championships.find(c => c.id === appState.currentChampionshipId);
            const champName = champ ? champ.name : "Torneio";

            let matchesHtml = '';
            group.matches.forEach((match, index) => {
                matchesHtml += `
                    <div class="match">
                        <div class="team">${match.names[0]}</div>
                        <div class="score-box"></div>
                        <div class="vs">vs</div>
                        <div class="score-box"></div>
                        <div class="team">${match.names[1]}</div>
                    </div>
                `;
            });

            const playersHtml = group.players.map(p => `<li>${p.name}</li>`).join('');

            const printStyles = `
                <style>
                    @page { margin: 20mm; }
                    body { 
                        font-family: Arial, sans-serif; 
                        margin: 0; 
                        color: #000; 
                        width: 100%;
                    }
                    h1 { text-align: center; font-size: 24px; margin-bottom: 5px; }
                    h2 { text-align: center; font-size: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; margin-top: 0; }
                    .players { margin-bottom: 20px; }
                    .players h3 { font-size: 18px; margin-bottom: 5px; }
                    .players ul { list-style: none; padding-left: 0; margin: 0; }
                    .players li { font-size: 16px; }
                    .match { 
                        display: flex; 
                        align-items: center; 
                        justify-content: space-between; 
                        padding: 20px 0; 
                        border-bottom: 1px dashed #999; 
                        page-break-inside: avoid;
                    }
                    .team { flex: 1; font-size: 18px; font-weight: bold; }
                    .team:last-of-type { text-align: right; }
                    .vs { font-size: 14px; font-weight: bold; margin: 0 10px; }
                    .score-box {
                        width: 60px;
                        height: 40px;
                        border: 2px solid #000;
                        margin: 0 10px;
                    }
                </style>
            `;

            const printWindow = window.open('', '_blank', 'width=800,height=600');
            printWindow.document.write(`
                <html>
                    <head>
                        <title>Imprimir - ${champName} - Grupo ${groupIndex + 1}</title>
                        ${printStyles}
                    </head>
                    <body>
                        <h1>${champName}</h1>
                        <h2>Grupo ${groupIndex + 1}</h2>
                        <div class="players">
                            <h3>Jogadores do Grupo:</h3>
                            <ul>${playersHtml}</ul>
                        </div>
                        <h2>Jogos</h2>
                        <div class="matches">
                            ${matchesHtml}
                        </div>
                    </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.focus();

            // Um pequeno delay para garantir que o DOM esteja pronto antes de imprimir
            setTimeout(() => {
                printWindow.print();
            }, 250);
        };

        const handleFinalizeGroups = async () => {
            if (!confirm("Finalizar Fase de Grupos? Isso irá gerar as chaves Ouro e Prata e bloquear os grupos.")) return;

            let goldSeriesPairs = [];
            let silverSeriesPairs = [];

            activeChampionship.groups.forEach(group => {
                const rankings = getRankings(group); // [p1, p2, p3, p4]

                const goldPair = {
                    id: `${rankings[0].id}_${rankings[1].id}`,
                    name: `${rankings[0].name} / ${rankings[1].name}`,
                    players: [rankings[0], rankings[1]] 
                };
                goldSeriesPairs.push(goldPair);

                const silverPair = {
                    id: `${rankings[2].id}_${rankings[3].id}`,
                    name: `${rankings[2].name} / ${rankings[3].name}`,
                    players: [rankings[2], rankings[3]]
                };
                silverSeriesPairs.push(silverPair);
            });

            // Revalida a regra de potência de 2 antes de gerar a chave
            if (![2, 4, 8, 16, 32].includes(goldSeriesPairs.length) || ![2, 4, 8, 16, 32].includes(silverSeriesPairs.length)) {
                 showModal("Erro de Geração", `A regra atual de mata-mata (sem Byes) exige que o número de duplas seja 2, 4, 8, 16 ou 32. Chave Ouro tem ${goldSeriesPairs.length} e Prata tem ${silverSeriesPairs.length}. Ajuste o número de jogadores antes de finalizar.`);
                 return;
            }

            try {
                const goldBracket = createBracket(goldSeriesPairs);
                const silverBracket = createBracket(silverSeriesPairs);

                const newChampData = {
                    ...activeChampionship,
                    status: 'knockout',
                    goldBracket: goldBracket,
                    silverBracket: silverBracket,
                };

                await saveActiveChampionship(newChampData);

                const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                await setDoc(champRef, { status: 'knockout' }, { merge: true });

            } catch (error) {
                console.error("Erro ao finalizar grupos:", error);
                showModal("Erro", "Ocorreu um erro ao gerar as chaves.");
            }
        };

        const handleConfirmKnockoutScore = async (bracketType, matchId) => {
            const val0 = document.getElementById(`k-${matchId}-s0`).value;
            const val1 = document.getElementById(`k-${matchId}-s1`).value;

            const score0 = val0 === '' ? null : parseInt(val0, 10);
            const score1 = val1 === '' ? null : parseInt(val1, 10);

            if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                showModal("Placar Inválido", "Ambos os placares devem ser preenchidos com números positivos (ou 0).");
                return;
            }
            if (score0 === score1) {
                showModal("Placar Inválido", "O placar do mata-mata não pode ser um empate.");
                return;
            }

            const newChampData = JSON.parse(JSON.stringify(activeChampionship));
            const bracketToUpdate = newChampData[bracketType];
            const match = bracketToUpdate.find(m => m.id === matchId);

            if (match) {
                match.score[0] = score0;
                match.score[1] = score1;

                if (score0 > score1) match.winner = match.pairs[0]; 
                else if (score1 > score0) match.winner = match.pairs[1];

                if (match.winner && match.nextMatchId) {
                    const nextMatch = bracketToUpdate.find(m => m.id === match.nextMatchId);
                    if (nextMatch) nextMatch.pairs[match.nextMatchSlot] = match.winner;
                }

                await saveActiveChampionship(newChampData); 
                await checkAndFinalizeChampionship(newChampData);
            }
        };

        /* =============================================================================
           Lógica de Cálculo de Ranking
           ============================================================================= */

        const checkAndFinalizeChampionship = async (champData) => {
            if (!champData.goldBracket || !champData.silverBracket || champData.goldBracket.length === 0 || champData.silverBracket.length === 0) {
                return; 
            }

            const maxRoundGold = Math.max(...champData.goldBracket.map(m => m.round));
            const maxRoundSilver = Math.max(...champData.silverBracket.map(m => m.round));

            const goldFinal = champData.goldBracket.find(m => m.round === maxRoundGold);
            const silverFinal = champData.silverBracket.find(m => m.round === maxRoundSilver);

            const goldWinner = goldFinal?.winner; 
            const silverWinner = silverFinal?.winner; 

            if (goldWinner && silverWinner) {
                const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);

                const champDoc = await getDoc(champRef);
                if (!champDoc.exists()) return; 

                const champDocData = champDoc.data();
                const wasAlreadyFinished = (champDocData.status === 'finished');

                const rankingId = champDocData.rankingId;
                if (!rankingId) {
                    showModal("Erro Crítico", "Este campeonato não está vinculado a nenhum ranking. Os pontos não podem ser salvos.");
                    console.error("Erro Crítico: Campeonato sem rankingId.");
                    return;
                }

                try {
                    const goldRunnerUp = goldFinal.pairs.find(p => p.id !== goldWinner.id);
                    const silverRunnerUp = silverFinal.pairs.find(p => p.id !== silverWinner.id);

                    const stats = getGlobalTournamentStats(champData);

                    const minGames = stats.length > 0 ? stats[0].gamesWon : 0;
                    const coveiros = stats.length > 0 ? stats.filter(p => p.gamesWon === minGames) : [];

                    const effectivePoints = champDocData.pointsConfig || DEFAULT_RANKING_POINTS;

                    // O update principal do status e vencedores deve ser feito antes da transação de ranking.
                    await setDoc(champRef, {
                        status: 'finished',
                        winnerGold: goldWinner.name, 
                        winnerSilver: silverWinner.name
                    }, { merge: true });

                    if (!wasAlreadyFinished) {
                        showModal("Calculando...", "Finalizando torneio e atualizando o ranking global. Aguarde...");

                        // APLICA O RANKING DENTRO DA TRANSAÇÃO
                        await updateGlobalRanking(champData, { goldWinner, goldRunnerUp, silverWinner, silverRunnerUp, coveiros }, effectivePoints, rankingId);

                        hideModal();
                        showModal("Sucesso!", `Ranking global atualizado! Campeões Ouro: ${goldWinner.name}. Campeões Prata: ${silverWinner.name}.`);
                    } else {
                         // Se já estava finalizado, apenas notifica sobre o ajuste de placar
                         showModal("Placar Atualizado", `O placar final foi alterado. O ranking global NÃO foi recalculado para evitar duplicidade.`);
                    }

                } catch (error) {
                    console.error("Erro ao finalizar e aplicar ranking:", error);
                    // O erro de "Firestone transactions require all reads to be executed before all writes"
                    // geralmente ocorre na função updateGlobalRanking, pois o bloco runTransaction foi mal construído.
                    // Garantindo que a função `updateGlobalRanking` use o `runTransaction` corretamente.
                    showModal("Erro Crítico", "Não foi possível aplicar o ranking. Verifique o console para detalhes.");
                }
            }
        };

        const updateGlobalRanking = async (champData, winners, pointsConfig, rankingId) => {
            // Garante que toda a lógica de leitura e escrita do ranking está dentro da transação
            await runTransaction(db, async (transaction) => {
                const playerPointsMap = new Map();

                // 1. CALCULAR PONTOS (Em memória)
                for (const player of champData.players) {
                    playerPointsMap.set(player.id, {
                        name: player.name,
                        points: pointsConfig.participation,
                        goldWins: 0,
                        silverWins: 0,
                        coveiroWins: 0 
                    });
                }
                if (winners.goldWinner) {
                    for (const player of winners.goldWinner.players) {
                        const p = playerPointsMap.get(player.id);
                        if (p) { p.points += pointsConfig.goldWinner; p.goldWins = 1; }
                    }
                }
                if (winners.goldRunnerUp) {
                    for (const player of winners.goldRunnerUp.players) {
                        const p = playerPointsMap.get(player.id);
                         if (p) p.points += pointsConfig.goldRunnerUp;
                    }
                }
                if (winners.silverWinner) {
                    for (const player of winners.silverWinner.players) {
                        const p = playerPointsMap.get(player.id);
                         if (p) { p.points += pointsConfig.silverWinner; p.silverWins = 1; }
                    }
                }
                if (winners.silverRunnerUp) {
                     for (const player of winners.silverRunnerUp.players) {
                        const p = playerPointsMap.get(player.id);
                         if (p) p.points += pointsConfig.silverRunnerUp;
                    }
                }
                if (winners.coveiros && winners.coveiros.length > 0) {
                    for (const coveiro of winners.coveiros) {
                        const p = playerPointsMap.get(coveiro.id);
                        if (p) { p.coveiroWins = 1; }
                    }
                }


                // 2. FASE DE LEITURA (Reads - Deve ocorrer antes de qualquer write dentro da transação)
                const playerDocsData = new Map();
                for (const [playerId, data] of playerPointsMap.entries()) {
                    const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId);
                    const playerDoc = await transaction.get(playerRef); // Leitura dentro da transação
                    playerDocsData.set(playerId, playerDoc); 
                }

                // 3. FASE DE ESCRITA (Writes)
                for (const [playerId, data] of playerPointsMap.entries()) {
                    const playerDoc = playerDocsData.get(playerId); 
                    const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId); 

                    if (!playerDoc.exists()) {
                        transaction.set(playerRef, {
                            name: data.name,
                            points: data.points,
                            goldWins: data.goldWins,
                            silverWins: data.silverWins,
                            coveiroWins: data.coveiroWins 
                        });
                    } else {
                        const oldData = playerDoc.data();
                        transaction.update(playerRef, {
                            name: data.name, 
                            points: (oldData.points || 0) + data.points,
                            goldWins: (oldData.goldWins || 0) + data.goldWins,
                            silverWins: (oldData.silverWins || 0) + data.silverWins,
                            coveiroWins: (oldData.coveiroWins || 0) + data.coveiroWins 
                        });
                    }
                }
            });
        };

        /* =============================================================================
           Funções Utilitárias (Cálculos de Grupos e Chaves)
           ============================================================================= */

        const getRankings = (group) => {
            const playerStats = {};
            group.players.forEach(p => {
                playerStats[p.id] = { id: p.id, name: p.name, gamesWon: 0 };
            });

            group.matches.forEach(match => {
                const [p1, p2, p3, p4] = match.p;
                const [s1, s2] = match.score;

                if (s1 !== null && !isNaN(s1)) {
                    playerStats[p1].gamesWon += s1;
                    playerStats[p2].gamesWon += s1;
                }
                if (s2 !== null && !isNaN(s2)) {
                    playerStats[p3].gamesWon += s2;
                    playerStats[p4].gamesWon += s2;
                }
            });

            return Object.values(playerStats).sort((a, b) => b.gamesWon - a.gamesWon);
        };


        // Calcula o total de games do TORNEIO (Grupos + Mata-Mata)
        const getGlobalTournamentStats = (champData) => {
            const playerStats = {};

            // 1. Inicializa todos os jogadores do torneio
            champData.players.forEach(p => {
                playerStats[p.id] = { id: p.id, name: p.name, gamesWon: 0 };
            });

            // 2. Soma os games da Fase de Grupos
            if (champData.groups) {
                champData.groups.forEach(group => {
                    group.matches.forEach(match => {
                        const [p1, p2, p3, p4] = match.p;
                        const [s1, s2] = match.score;

                        if (s1 !== null && !isNaN(s1)) {
                            if (playerStats[p1]) playerStats[p1].gamesWon += s1;
                            if (playerStats[p2]) playerStats[p2].gamesWon += s1;
                        }
                        if (s2 !== null && !isNaN(s2)) {
                            if (playerStats[p3]) playerStats[p3].gamesWon += s2;
                            if (playerStats[p4]) playerStats[p4].gamesWon += s2;
                        }
                    });
                });
            }

            // 3. Soma os games do Mata-Mata (Ouro e Prata)
            const allKnockoutMatches = (champData.goldBracket || []).concat(champData.silverBracket || []);

            allKnockoutMatches.forEach(match => {
                const [pair1, pair2] = match.pairs;
                const [s0, s1] = match.score;

                // Não conta jogos de Bye no placar, mas conta a folga como vitória
                if (s0 !== null && !isNaN(s0) && pair1 && pair1.players) {
                    pair1.players.forEach(player => {
                        if (playerStats[player.id]) {
                            playerStats[player.id].gamesWon += s0;
                        }
                    });
                }

                if (s1 !== null && !isNaN(s1) && pair2 && pair2.players) {
                    pair2.players.forEach(player => {
                        if (playerStats[player.id]) {
                            playerStats[player.id].gamesWon += s1;
                        }
                    });
                }
            });

            // 4. Retorna a lista ordenada por games (do menor para o maior)
            return Object.values(playerStats).sort((a, b) => a.gamesWon - b.gamesWon);
        };


        // Cria a estrutura de chave de mata-mata (apenas potências de 2)
        const createBracket = (bracketPairs) => {
            // Sorteio aleatório das duplas (cumprindo requisito)
            const shuffledPairs = [...bracketPairs].sort(() => 0.5 - Math.random());
            const bracket = [];
            const numPairs = bracketPairs.length;

            // Se o número de duplas não for uma potência de 2, retorna vazio (será bloqueado antes)
            if (![2, 4, 8, 16, 32].includes(numPairs)) return [];

            const numRounds = Math.log2(numPairs); // log2(4) = 2 rodadas

            // Loop crescente (Rodada 1, Rodada 2, ...)
            for (let r = 1; r <= numRounds; r++) { // r=1 (Semi), r=2 (Final)

                const matchesInRound = numPairs / Math.pow(2, r); 

                for (let m = 0; m < matchesInRound; m++) { 
                    const matchId = `R${r}_M${m+1}`;
                    let nextMatchId = null;
                    let nextMatchSlot = null; 

                    if (r < numRounds) { // Se não for a rodada final
                        const nextRoundMatchIndex = Math.floor(m / 2); 
                        nextMatchId = `R${r+1}_M${nextRoundMatchIndex+1}`;
                        nextMatchSlot = m % 2; 
                    }

                    const match = {
                        id: matchId,
                        round: r, 
                        pairs: [null, null], 
                        score: [null, null],
                        winner: null,
                        nextMatchId: nextMatchId,
                        nextMatchSlot: nextMatchSlot,
                    };

                    // Preenche a Rodada 1 com as duplas sorteadas
                    if (r === 1) {
                        const index1 = m * 2;
                        const index2 = m * 2 + 1;
                        match.pairs[0] = shuffledPairs[index1] || null;
                        match.pairs[1] = shuffledPairs[index2] || null;
                    }

                    bracket.push(match);
                }
            }

            return bracket;
        };


        /* =============================================================================
           Funções de PDF
           ============================================================================= */

        const handlePrintRankingPDF = () => {
            // Pega a instância global do jsPDF carregada no <head>
            const { jsPDF } = window.jspdf;
            if (!jsPDF) {
                showModal("Erro", "Biblioteca PDF (jsPDF) não foi carregada.");
                return;
            }

            try {
                const doc = new jsPDF();

                const currentRanking = allRankings.find(r => r.id === appState.currentRankingId);
                const rankingName = currentRanking ? currentRanking.name : "Ranking";
                const title = `Ranking Geral: ${rankingName}`;

                doc.setFontSize(18);
                doc.text(title, 105, 22, { align: 'center' }); // Centraliza o título

                const sortedPlayers = [...globalPlayers].sort((a, b) => b.points - a.points);

                const head = [['Pos.', 'Jogador', 'Pontos', 'Ouro', 'Prata', 'Coveiro']];
                const body = sortedPlayers.map((p, index) => [
                    `${index + 1}º`,
                    p.name,
                    p.points || 0,
                    p.goldWins || 0,
                    p.silverWins || 0,
                    p.coveiroWins || 0
                ]);

                // Usa o plugin autoTable
                doc.autoTable({
                    startY: 30,
                    head: head,
                    body: body,
                    headStyles: { fillColor: [52, 152, 219] }, // Cor Azul Principal
                    styles: { halign: 'center', textColor: [31, 41, 55] },
                    headStyles: { fillColor: [209, 213, 219], textColor: [75, 85, 99] },
                    columnStyles: {
                        1: { halign: 'left' } // Alinha o nome do jogador à esquerda
                    }
                });

                doc.save(`ranking_${rankingName.toLowerCase().replace(/\s/g, '_')}.pdf`);

            } catch (error) {
                console.error("Erro ao gerar PDF do ranking:", error);
                showModal("Erro", "Não foi possível gerar o PDF. " + error.message);
            }
        };

        const handlePrintChampionshipPDF = () => {
            const { jsPDF } = window.jspdf;
            if (!jsPDF) {
                showModal("Erro", "Biblioteca PDF (jsPDF) não foi carregada.");
                return;
            }

            const champ = championships.find(c => c.id === appState.currentChampionshipId);
            if (!champ || !activeChampionship) {
                showModal("Erro", "Dados do campeonato não carregados.");
                return;
            }

            try {
                const doc = new jsPDF();
                let yPos = 22; // Posição vertical inicial

                // 1. Título
                doc.setFontSize(18);
                doc.text(champ.name, 105, yPos, { align: 'center' });
                yPos += 10;

                // 2. Tabela de Resultados Finais
                doc.setFontSize(14);
                doc.text("Resultados Finais", 14, yPos);
                yPos += 7;

                const finalResults = [];
                // Ouro
                const maxRoundGold = Math.max(...activeChampionship.goldBracket.map(m => m.round));
                const goldFinal = activeChampionship.goldBracket.find(m => m.round === maxRoundGold);
                if (goldFinal?.winner) {
                    finalResults.push(['Campeões Ouro', goldFinal.winner.name]);
                    const goldRunnerUp = goldFinal.pairs.find(p => p.id !== goldFinal.winner.id);
                    if (goldRunnerUp) finalResults.push(['Vice Ouro', goldRunnerUp.name]);
                }
                // Prata
                const maxRoundSilver = Math.max(...activeChampionship.silverBracket.map(m => m.round));
                const silverFinal = activeChampionship.silverBracket.find(m => m.round === maxRoundSilver);
                if (silverFinal?.winner) {
                    finalResults.push(['Campeões Prata', silverFinal.winner.name]);
                    const silverRunnerUp = silverFinal.pairs.find(p => p.id !== silverFinal.winner.id);
                    if (silverRunnerUp) finalResults.push(['Vice Prata', silverRunnerUp.name]);
                }

                // Coveiro
                const stats = getGlobalTournamentStats(activeChampionship);

                if (stats.length > 0) {
                    const minGames = stats[0].gamesWon;
                    const coveiros = stats.filter(p => p.gamesWon === minGames);
                    finalResults.push(['Coveiro(s)', coveiros.map(c => c.name).join(' / ')]);
                }

                doc.autoTable({
                    startY: yPos,
                    head: [['Prêmio', 'Dupla/Jogador']],
                    body: finalResults,
                    headStyles: { fillColor: [52, 73, 94], textColor: [255, 255, 255] },
                    styles: { textColor: [31, 41, 55] },
                    theme: 'striped',
                });
                yPos = doc.autoTable.previous.finalY + 10; // Atualiza a posição Y

                // 3. Fase de Grupos (em nova página)
                doc.addPage();
                yPos = 22;
                doc.setFontSize(18);
                doc.text("Resultados da Fase de Grupos", 105, yPos, { align: 'center' });
                yPos += 10;

                activeChampionship.groups.forEach((group, index) => {
                    // Verifica se precisa de uma nova página
                    if (yPos > 240) {
                        doc.addPage();
                        yPos = 22;
                    }

                    doc.setFontSize(14);
                    doc.text(`Grupo ${index + 1}`, 14, yPos);
                    yPos += 7;

                    // Tabela de Jogos do Grupo
                    const matchesBody = group.matches.map(m => [
                        m.names[0],
                        `${m.score[0] === null ? '-' : m.score[0]} vs ${m.score[1] === null ? '-' : m.score[1]}`,
                        m.names[1]
                    ]);

                    doc.autoTable({
                        startY: yPos,
                        head: [['Dupla 1', 'Placar', 'Dupla 2']],
                        body: matchesBody,
                        headStyles: { fillColor: [52, 152, 219], textColor: [255, 255, 255] },
                        styles: { halign: 'center', textColor: [31, 41, 55] },
                        columnStyles: { 0: { halign: 'left' }, 2: { halign: 'right' } }
                    });
                    yPos = doc.autoTable.previous.finalY + 5;

                    // Tabela de Ranking do Grupo
                    const rankings = getRankings(group);
                    const rankingsBody = rankings.map((p, rIndex) => [
                        `${rIndex + 1}º`,
                        p.name,
                        p.gamesWon
                    ]);

                    doc.autoTable({
                        startY: yPos,
                        head: [['Pos.', 'Jogador', 'Games Vencidos']],
                        body: rankingsBody,
                        theme: 'grid',
                        styles: { halign: 'center', fontSize: 9, textColor: [31, 41, 55] },
                        headStyles: { fillColor: [209, 213, 219], textColor: [75, 85, 99], fontSize: 10 },
                    });
                    yPos = doc.autoTable.previous.finalY + 12;
                });

                // 4. Chaves (Mata-Mata)
                if (yPos > 180) { // Se não houver muito espaço
                    doc.addPage();
                    yPos = 22;
                } else {
                    yPos += 5; // Espaçamento
                }

                doc.setFontSize(18);
                doc.text("Resultados do Mata-Mata", 105, yPos, { align: 'center' });
                yPos += 10;

                // Tabela Série Ouro
                doc.setFontSize(16);
                doc.text("Série Ouro", 14, yPos);
                yPos += 7;
                const goldBody = activeChampionship.goldBracket.map(m => {
                    const roundTitle = m.round === maxRoundGold ? 'Final'
                        : m.round === maxRoundGold - 1 ? 'Semi-Final'
                        : m.round === maxRoundGold - 2 ? 'Quartas' : `Rodada ${m.round}`;

                    const pair1Name = m.pairs[0]?.name || '-';
                    const pair2Name = m.pairs[1]?.name || '-';
                    const score = m.score[0] === null || m.score[1] === null 
                        ? ' - '
                        : `${m.score[0]} vs ${m.score[1]}`;

                    return [
                        roundTitle,
                        pair1Name,
                        score,
                        pair2Name
                    ];
                });
                doc.autoTable({
                    startY: yPos,
                    head: [['Rodada', 'Dupla 1', 'Placar', 'Dupla 2']],
                    body: goldBody,
                    headStyles: { fillColor: [251, 191, 36], textColor: [31, 41, 55] }, // Dourado
                    styles: { halign: 'center', textColor: [31, 41, 55] },
                    columnStyles: { 1: { halign: 'left' }, 3: { halign: 'right' } }
                });
                yPos = doc.autoTable.previous.finalY + 10;

                // Tabela Série Prata
                doc.setFontSize(16);
                doc.text("Série Prata", 14, yPos);
                yPos += 7;
                const silverBody = activeChampionship.silverBracket.map(m => {
                    const roundTitle = m.round === maxRoundSilver ? 'Final'
                        : m.round === maxRoundSilver - 1 ? 'Semi-Final'
                        : m.round === maxRoundSilver - 2 ? 'Quartas' : `Rodada ${m.round}`;

                    const pair1Name = m.pairs[0]?.name || '-';
                    const pair2Name = m.pairs[1]?.name || '-';
                    const score = m.score[0] === null || m.score[1] === null 
                        ? ' - '
                        : `${m.score[0]} vs ${m.score[1]}`;

                    return [
                        roundTitle,
                        pair1Name,
                        score,
                        pair2Name
                    ];
                });
                doc.autoTable({
                    startY: yPos,
                    head: [['Rodada', 'Dupla 1', 'Placar', 'Dupla 2']],
                    body: silverBody,
                    headStyles: { fillColor: [156, 163, 175], textColor: [31, 41, 55] }, // Prata
                    styles: { halign: 'center', textColor: [31, 41, 55] },
                    columnStyles: { 1: { halign: 'left' }, 3: { halign: 'right' } }
                });

                // 5. Salvar
                doc.save(`resultados_${champ.name.toLowerCase().replace(/\s/g, '_')}.pdf`);

            } catch (error) {
                 console.error("Erro ao gerar PDF do campeonato:", error);
                showModal("Erro", "Não foi possível gerar o PDF. " + error.message);
            }
        };


        /* =============================================================================
           Inicialização do App (Autenticação e Listeners Globais)
           ============================================================================= */

        const listenToGlobalPlayers = () => {
            unsubscribeGlobalPlayers(); 

            // Se nenhum ranking estiver selecionado (ex: durante o carregamento), não faz nada
            if (!appState.currentRankingId) {
                globalPlayers = [];
                if(appState.currentView === 'globalRanking') render();
                return;
            }

            // O caminho da coleção agora é dinâmico
            const playersCollectionRef = collection(db, 'users', appState.userId, 'rankings', appState.currentRankingId, 'players');
            const q = query(playersCollectionRef);

            unsubscribeGlobalPlayers = onSnapshot(q, (querySnapshot) => {
                globalPlayers = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                if (appState.currentView === 'globalRanking') {
                    render();
                }
                if (appState.currentView === 'championshipView' && activeChampionship?.status === 'registration') {
                    render();
                }

            }, (error) => {
                console.error(`Erro ao carregar ranking ${appState.currentRankingId}:`, error);
                showModal("Erro", "Não foi possível carregar o ranking selecionado.");
                globalPlayers = [];
                if(appState.currentView === 'globalRanking' || appState.currentView === 'championshipView') render();
            });
        };

        const listenToChampionships = () => {
            unsubscribeChampionships();
            // Usa o appState.userId (que será o MESTRE_USER_ID)
            const champCollectionRef = collection(db, 'users', appState.userId, 'championships');
            const q = query(champCollectionRef);

            unsubscribeChampionships = onSnapshot(q, (querySnapshot) => {
                championships = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                if (appState.currentView === 'championshipList') {
                    render();
                }
                if (appState.isTelaoMode && appState.currentView === 'telaoView') {
                    render();
                }

            }, (error) => {
                console.error("Erro ao carregar campeonatos:", error);
                showModal("Erro", "Não foi possível carregar o histórico de campeonatos.");
            });
        };

        const listenToActiveChampionship = (champId) => {
            unsubscribeActiveChampionship();
            // Usa o appState.userId (que será o MESTRE_USER_ID)
            const champDataRef = doc(db, 'users', appState.userId, 'championships', champId, 'data', 'main');

            unsubscribeActiveChampionship = onSnapshot(champDataRef, (docSnap) => {
                if (docSnap.exists()) {
                    activeChampionship = { id: docSnap.id, ...docSnap.data() };
                    render(); // Renderiza a tela atual (seja 'championshipView' ou 'telaoView')
                } else {
                    showModal("Erro", "Não foi possível carregar os dados deste campeonato. (O doc 'data/main' não foi encontrado).");
                    if (!appState.isTelaoMode) navigateTo('championshipList');
                    else mainContent.innerHTML = `<h1 class="text-4xl text-red-500 text-center p-10">Erro: Campeonato não encontrado.</h1>`;
                }
            }, (error) => {
                console.error("Erro ao carregar campeonato ativo:", error);
                showModal("Erro", "Não foi possível carregar este campeonato. Verifique as regras do Firestore.");
                if (!appState.isTelaoMode) navigateTo('championshipList');
                else mainContent.innerHTML = `<h1 class="text-4xl text-red-500 text-center p-10">Erro de conexão.</h1>`;
            });
        };

        const listenToRankingsList = () => {
            unsubscribeRankingsList();
            const rankingsDocRef = doc(db, 'users', appState.userId, 'app_data', 'rankings');

            unsubscribeRankingsList = onSnapshot(rankingsDocRef, async (docSnap) => {
                let list = [];
                if (docSnap.exists()) {
                    list = docSnap.data().list || [];
                }

                // Se for a primeira vez e a lista estiver vazia, cria um ranking padrão
                if (list.length === 0) {
                    try {
                        const defaultRanking = { id: "ranking_geral", name: "Ranking Geral" };
                        await setDoc(rankingsDocRef, { list: [defaultRanking] });
                        allRankings = [defaultRanking];
                    } catch (error) {
                        console.error("Erro ao criar ranking padrão:", error);
                        showModal("Erro Crítico", "Não foi possível inicializar a lista de rankings.");
                        return;
                    }
                } else {
                    allRankings = list;
                }

                // Se nenhum ranking estiver selecionado no appState, OU se o ranking selecionado
                // foi excluído, seleciona o primeiro da lista
                const selectedRankingExists = allRankings.some(r => r.id === appState.currentRankingId);

                if ((!appState.currentRankingId || !selectedRankingExists) && allRankings.length > 0) {
                    appState.currentRankingId = allRankings[0].id;
                } else if (allRankings.length === 0) {
                    appState.currentRankingId = null; // Nenhum ranking existe
                }

                // Esta chamada é crucial para que o `globalPlayers` seja preenchido na primeira carga
                listenToGlobalPlayers();

                // Re-renderiza a tela atual (pode ser a 'championshipList' ou 'globalRanking' que dependem dessa lista)
                // Não chama o render() se estivermos no modo Telão, pois o 'navigateTo' cuidará disso.
                if (!appState.isTelaoMode) {
                    render();
                }

            }, (error) => {
                console.error("Erro ao carregar lista de rankings:", error);
                showModal("Erro Crítico", "Não foi possível carregar a lista de rankings.");
            });
        };

        // Ponto de entrada da aplicação
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Erro na autenticação anônima:", error);
                    let errorMessage = "Não foi possível conectar ao Firebase. Verifique sua conexão.";
                    if (error.code === 'auth/configuration-not-found') {
                        errorMessage = "Erro de Autenticação: O 'Login Anônimo' (Anonymous) não está ATIVADO no seu painel do Firebase.";
                    }
                    showModal("Erro de Autenticação", errorMessage);
                    return;
                }
            }

            if (user && !appState.isAuthReady) {

                const effectiveUserId = MESTRE_USER_ID; 

                appState = { ...appState, userId: effectiveUserId, isAuthReady: true };
                userIdFooter.textContent = effectiveUserId; // Mostra o ID Mestre no rodapé

                // Lógica de Roteamento (Normal vs Telão)

                // 1. Verifica os parâmetros da URL
                const urlParams = new URLSearchParams(window.location.search);
                const telaoChampId = urlParams.get('champId');

                // 2. Inicia os listeners globais (necessários para ambos os modos)
                listenToChampionships();
                listenToRankingsList(); // Esta função vai chamar listenToGlobalPlayers()

                if (urlParams.has('telao') && telaoChampId) {
                    // --- MODO TELÃO ---
                    appState.isTelaoMode = true;
                    appState.isAdmin = false; // Telão é sempre visitante

                    // Adiciona estilos para a view limpa
                    const telaoStyles = document.createElement('style');
                    telaoStyles.innerHTML = `
                        body { background-color: #F7F7F7; } /* Fundo Quase Branco para TV */
                        /* Ajusta o container para telas largas, mantendo um padding */
                        #app-container { max-width: 100%; padding: 1rem 2rem; }
                        header, footer { display: none !important; }
                    `;
                    document.head.appendChild(telaoStyles);

                    // Navega direto para o telão
                    navigateTo('telaoView', telaoChampId);

                } else {
                    // --- MODO NORMAL ---
                    appState.isTelaoMode = false;
                    navigateTo('login');
                }
            }
        });

    </script>
</body>
</html>
