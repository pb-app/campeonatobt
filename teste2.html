                    // Bot√£o de Impress√£o (para ficha)
                    const printButton = `
                        <button class="print-group-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-3 rounded-lg shadow-sm transition-all flex items-center gap-2 text-sm" data-group-index="${groupIndex}">
                            ${icons.printer}
                        </button>
                    `;

                    return `
                    <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 animate-fade-in border border-gray-200">
                        <div class="flex justify-between items-center mb-5">
                            <h3 class="text-2xl font-bold text-cyan-600">Grupo ${groupIndex + 1}</h3>
                            ${printButton}
                        </div>
                        <div class="space-y-4 mb-6">${matchesHtml}</div>
                        <div>
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">Ranking do Grupo</h4>
                            <table class="w-full text-left">
                                <thead>
                                    <tr class="bg-amber-100">
                                        <th class="p-3 rounded-l-lg text-gray-600">Pos.</th>
                                        <th class="p-3 text-gray-600">Jogador</th>
                                        <th class="p-3 rounded-r-lg text-gray-600">Games Vencidos</th>
                                    </tr>
                                </thead>
                                <tbody>${rankingsHtml}</tbody>
                            </table>
                            <div class="flex justify-between mt-2 text-sm">
                                <span class="text-emerald-600">‚ñ≤ Dupla Ouro ü•á</span>
                                <span class="text-orange-600">‚ñº Dupla Prata ü•à</span>
                            </div>
                        </div>
                    </div>
                    `;
                }).join('');

                // Bot√£o de finalizar S√ì aparece para admin E S√ì na fase de grupos
                const finalizeButtonHtml = (appState.isAdmin && activeChampionship.status === 'groups') ? `
                <div class="mt-8 text-center">
                    <button
                        id="finalize-groups-btn"
                        type="button"
                        ${!allScoresFilled ? 'disabled' : ''}
                        class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-4 px-8 rounded-lg shadow-xl transition-all flex items-center justify-center gap-3 text-lg mx-auto disabled:opacity-50 disabled:cursor-not-allowed">
                        ${icons.trophy}
                        ${allScoresFilled ? "Finalizar Grupos e Gerar Chaves" : "Preencha todos os placares"}
                    </button>
                </div>
                ` : '';

                return `
                    <div class="space-y-8 animate-fade-in">
                        ${groupsHtml}
                        ${finalizeButtonHtml}
                    </div>
                `;
            };

            // (ADMIN) -- Sub-tela: Chaves (Mata-Mata) --
            const renderKnockoutView = (isFinished) => {
                // Chamadas de renderBracket sem o √≠cone nos par√¢metros (apenas o t√≠tulo)
                const goldHtml = renderBracket('S√©rie Ouro ü•á', activeChampionship.goldBracket, 'goldBracket', isFinished);
                const silverHtml = renderBracket('S√©rie Prata ü•à', activeChampionship.silverBracket, 'silverBracket', isFinished);

                // L√≥gica do Coveiro
                let coveiroHtml = '';
                if (activeChampionship.groups && activeChampionship.groups.length > 0) {
                    const stats = getGlobalTournamentStats(activeChampionship);

                    if (stats.length > 0) {
                        const minGames = stats[0].gamesWon;
                        const coveiros = stats.filter(p => p.gamesWon === minGames); // Pega todos que empataram em √∫ltimo
                        const coveiroNames = coveiros.map(c => c.name).join(' / ');

                        coveiroHtml = `
                        <div class="bg-white text-gray-800 p-6 rounded-lg shadow-xl mt-8 text-center animate-fade-in border border-gray-200">
                            <h4 class="text-2xl font-black uppercase tracking-wider text-rose-600">üëª Pr√™mio Coveiro</h4>
                            <p class="text-4xl font-extrabold text-gray-900 mt-2">${coveiroNames}</p>
                            <p class="text-sm text-gray-500">Com apenas ${minGames} games marcados no torneio.</p>
                        </div>
                        `;
                    }
                }
                return `<div class="animate-fade-in">${goldHtml}${silverHtml}${coveiroHtml}</div>`;
            };

            // (ADMIN) -- Helper: Renderiza uma Chave (Bracket) --
            const renderBracket = (title, bracket, bracketType, isFinished) => {
                const rounds = {};
                if (!bracket || bracket.length === 0) {
                     return `<div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 mb-8 border border-gray-200">
                         <h3 class="text-3xl font-bold mb-6 text-cyan-600 flex items-center gap-3">
                             ${title}
                         </h3>
                         <p class="text-gray-500">Chave ainda n√£o gerada. √â necess√°rio 4, 8, 16 ou 32 duplas.</p>
                      </div>`;
                }

                bracket.forEach(match => {
                    if (!rounds[match.round]) rounds[match.round] = [];
                    rounds[match.round].push(match);
                });

                const maxRound = Math.max(...bracket.map(m => m.round));
                const final = bracket.find(m => m.round === maxRound);
                const champion = final?.winner; 

                const isGold = bracketType === 'goldBracket';
                // Fundo do Card de Campe√£o
                const cardStyle = isGold 
                    ? 'bg-gradient-to-r from-yellow-300 via-orange-400 to-orange-500 text-white' // Gold/Orange Style
                    : 'bg-gradient-to-r from-gray-300 via-gray-400 to-gray-500 text-gray-900'; // Silver Style

                // Destaque do Nome do Campe√£o
                const championNameStyle = isGold ? 'text-4xl font-extrabold text-white' : 'text-4xl font-extrabold text-gray-800';

                const championHtml = champion ? `
                <div class="${cardStyle} p-6 rounded-lg shadow-2xl mb-8 text-center animate-fade-in">
                    <h4 class="text-xl font-black uppercase tracking-wider ${isGold ? 'text-white' : 'text-gray-800'}">Campe√µes</h4>
                    <p class="${championNameStyle}">${champion.name}</p>
                </div>
                ` : '';

                const roundsHtml = Object.keys(rounds).sort((a,b) => a-b).map(roundNum => {
                    const roundTitle = Number(roundNum) === maxRound ? 'Final'
                        : Number(roundNum) === maxRound - 1 ? 'Semi-Final'
                        : Number(roundNum) === maxRound - 2 ? 'Quartas de Final'
                        : `Rodada ${roundNum}`;

                    const matchesHtml = rounds[roundNum].map(match => {
                        const pair1 = match.pairs[0]; 
                        const pair2 = match.pairs[1]; 

                        // ==================================================
                        // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                        // ==================================================
                        const p1_isBye = pair1 && pair1.id === 'BYE';
                        const p2_isBye = pair2 && pair2.id === 'BYE';
                        const isByeMatch = p1_isBye || p2_isBye;
                        // ==================================================
                        // === FIM DA ALTERA√á√ÉO (BYE) ===
                        // ==================================================

                        const isPair1Winner = match.winner && pair1 && match.winner.id === pair1.id;
                        const isPair2Winner = match.winner && pair2 && match.winner.id === pair2.id;
                        const score1 = match.score[0];
                        const score2 = match.score[1];
                        const hasScore = score1 !== null && score2 !== null;

                        // NOVO: Desabilita inputs se N√ÉO for admin
                        const isDisabled = !appState.isAdmin; // (Removido o 'isFinished' daqui)
                        const adminButtonsClass = appState.isAdmin ? '' : 'hidden';

                        // NOVO: Bot√£o de Edi√ß√£o (‚úèÔ∏è)
                        // Aparece se o jogo J√Å tiver placar, ou se o torneio estiver finalizado
                        // ALTERA√á√ÉO (BYE): N√£o mostra bot√µes se for jogo 'Bye'
                        const showEditButton = (hasScore || isFinished) && !isByeMatch;
                        const showConfirmButton = !showEditButton && pair1 && pair2 && !isByeMatch; // S√≥ mostra check se tiver 2 duplas E n√£o for Bye

                        // ALTERA√á√ÉO (BYE): Define o nome a ser exibido
                        const pair1Name = p1_isBye ? '--- BYE ---' : (pair1 ? pair1.name : 'Aguardando...');
                        const pair2Name = p2_isBye ? '--- BYE ---' : (pair2 ? pair2.name : 'Aguardando...');
                        
                        // ALTERA√á√ÉO (BYE): Desabilita inputs se for Bye
                        const inputDisabled = isDisabled || isByeMatch;

                        return `
                        <div class="bg-amber-50 rounded-lg shadow-sm border border-amber-200 p-4">
                            <div class="flex justify-between items-center mb-2">
                                <span class="font-medium text-sm ${isPair1Winner ? 'text-emerald-600 font-bold' : 'text-gray-800'} ${p1_isBye ? 'text-gray-400 italic' : ''}">
                                    ${pair1Name}
                                </span>
                                <input
                                    type="number"
                                    min="0"
                                    value="${score1 === null ? '' : score1}"
                                    id="k-${match.id}-s0"
                                    class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center font-bold focus:outline-none focus:ring-2 focus:ring-cyan-500 ${inputDisabled ? 'opacity-70' : ''}"
                                    ${inputDisabled ? 'disabled' : ''}
                                />
                            </div>
                            
                            <div class="flex items-center my-2">
                                <div class="flex-grow border-t border-gray-300"></div>
                                <span class="mx-2 text-xs text-gray-500">vs</span>
                                <div class="flex-grow border-t border-gray-300"></div>
                            </div>

                            <div class="flex justify-between items-center">
                                <span class="font-medium text-sm ${isPair2Winner ? 'text-emerald-600 font-bold' : 'text-gray-800'} ${p2_isBye ? 'text-gray-400 italic' : ''}">
                                    ${pair2Name}
                                </span>
                                <input
                                    type="number"
                                    min="0"
                                    value="${score2 === null ? '' : score2}"
                                    id="k-${match.id}-s1"
                                    class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center font-bold focus:outline-none focus:ring-2 focus:ring-cyan-500 ${inputDisabled ? 'opacity-70' : ''}"
                                    ${inputDisabled ? 'disabled' : ''}
                                />
                            </div>
                            
                            <div class="text-center mt-3 ${adminButtonsClass}">
                                <button 
                                    class="confirm-knockout-score-btn p-2 w-full bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg shadow-md transition-all ${showConfirmButton ? '' : 'hidden'}"
                                    data-bracket-type="${bracketType}"
                                    data-match-id="${match.id}"
                                    title="Confirmar Placar">
                                    ${icons.check}
                                </button>
                                
                                <button 
                                    class="edit-knockout-score-btn p-2 w-full bg-orange-500 hover:bg-orange-600 text-white rounded-lg shadow-md transition-all ${showEditButton ? '' : 'hidden'}"
                                    data-bracket-type="${bracketType}"
                                    data-match-id="${match.id}"
                                    title="Editar Placar">
                                    ${icons.edit}
                                </button>
                            </div>
                        </div>
                        `;
                    }).join('');

                    return `
                    <div class="flex flex-col space-y-6 flex-shrink-0 w-72 sm:w-80">
                        <h4 class="text-xl font-semibold text-gray-800">${roundTitle}</h4>
                        ${matchesHtml}
                    </div>
                    `;
                }).join('');

                return `
                <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 mb-8 border border-gray-200">
                    <h3 class="text-3xl font-bold mb-6 text-cyan-600">
                        ${title}
                    </h3>
                    ${championHtml}
                    <div class="flex gap-4 sm:gap-6 pb-4 overflow-x-auto">
                        ${roundsHtml}
                    </div>
                </div>
                `;
            };

            /* =============================================================================
               TELA 4: Vis√£o do Tel√£o (READ-ONLY)
               ============================================================================= */

            // Fun√ß√£o "Router" da tela do TEL√ÉO (READ-ONLY)
            const renderTelaoView = () => {
                 if (!activeChampionship) {
                    mainContent.innerHTML = `
                    <div class="text-center py-20 animate-fade-in">
                        <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-cyan-600 mx-auto"></div>
                        <p class="mt-4 text-gray-500">Aguardando dados do torneio...</p>
                    </div>
                    `;
                    return;
                }

                const champInfo = championships.find(c => c.id === appState.currentChampionshipId);
                const champName = champInfo ? champInfo.name : "Campeonato";

                // T√≠tulo do Tel√£o
                let html = `<h1 class="text-4xl sm:text-6xl font-bold text-center text-cyan-600 my-8 animate-fade-in">üèñÔ∏è ${champName} üéæ</h1>`;

                // Define o conte√∫do baseado no status
                let contentHtml = '';
                if (champInfo?.status === 'finished') {
                    contentHtml = renderGroupStage_ReadOnly() + renderKnockoutView_ReadOnly(true);
                } else if (activeChampionship.status === 'knockout') {
                    contentHtml = renderGroupStage_ReadOnly() + renderKnockoutView_ReadOnly(false);
                } else if (activeChampionship.status === 'groups') {
                    contentHtml = renderGroupStage_ReadOnly();
                } else { // 'registration'
                    contentHtml = renderPlayerRegistration_ReadOnly();
                }

                if (activeChampionship.status !== 'registration') {
                    html += `
                    <div class="flex flex-wrap justify-center gap-6 animate-fade-in">
                        ${contentHtml}
                    </div>
                    `;
                } else {
                    html += contentHtml;
                }

                mainContent.innerHTML = html;

                // Ajuste do fundo para o modo tel√£o (definido no body global)
                if (appState.isTelaoMode) {
                     document.body.style.backgroundColor = '#FFFAF0'; // bg-amber-50
                }
            };

            // (TEL√ÉO) -- Sub-tela: Registro de Jogadores (Read-Only) --
            const renderPlayerRegistration_ReadOnly = () => {
                const playerCount = activeChampionship.players.length;

                const playersListHtml = playerCount === 0
                    ? `<p class="text-gray-500 text-center py-4 text-2xl">Aguardando inscri√ß√£o dos jogadores...</p>`
                    : activeChampionship.players.map(player => `
                        <div class="bg-white p-4 rounded-lg animate-fade-in-sm border border-gray-200 shadow-sm">
                            <span class="text-gray-800 font-medium text-2xl">${player.name}</span>
                        </div>
                    `).join('');

                return `
                    <div class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 lg:p-12 animate-fade-in max-w-4xl mx-auto border border-gray-200">
                        <div class="bg-white rounded-xl shadow-lg p-6 sm:p-8 border border-gray-200">
                            <h3 class="text-3xl sm:text-4xl font-semibold mb-6 text-cyan-600 flex items-center gap-3">
                                ${icons.users}
                                Jogadores Inscritos (${playerCount})
                            </h3>
                            <div class="max-h-[70vh] overflow-y-auto pr-2 space-y-3">
                                ${playersListHtml}
                            </div>
                        </div>
                    </div>
                `;
            };

            // (TEL√ÉO) -- Sub-tela: Fase de Grupos (Read-Only) --
            const renderGroupStage_ReadOnly = () => {
                const groupsHtml = activeChampionship.groups.map((group, groupIndex) => {
                    const rankings = getRankings(group);

                    const matchesHtml = group.matches.map((match, matchIndex) => {
                        const score1 = match.score[0];
                        const score2 = match.score[1];

                        return `
                        <div class="bg-amber-100 p-3 sm:p-4 rounded-lg border border-amber-200">
                            <div class="flex flex-col sm:flex-row justify-between items-center gap-2">
                                <span class="text-base text-gray-700 text-center sm:text-left">${match.names[0]}</span>
                                <span class="font-bold text-cyan-600">vs</span>
                                <span class="text-base text-gray-700 text-center sm:text-right">${match.names[1]}</span>
                            </div>
                            <div class="flex justify-center items-center gap-3 mt-3">
                                <span class="w-20 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-2xl font-bold opacity-70">
                                    ${score1 === null ? '-' : score1}
                                </span>
                                <span class="text-gray-500 text-xl">-</span>
                                 <span class="w-20 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-2xl font-bold opacity-70">
                                    ${score2 === null ? '-' : score2}
                                </span>
                            </div>
                        </div>
                        `;
                    }).join('');

                    const rankingsHtml = rankings.map((player, rankIndex) => `
                        <tr class="border-b border-gray-200 ${rankIndex < 2 ? 'text-emerald-600' : 'text-orange-600'}">
                            <td class="p-3 font-bold text-lg">${rankIndex + 1}¬∫</td>
                            <td class="p-3 text-lg text-gray-800">${player.name}</td>
                            <td class="p-3 font-bold text-lg">${player.gamesWon}</td>
                        </tr>
                    `).join('');

                    return `
                    <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 animate-fade-in w-full sm:max-w-sm border border-gray-200">
                        <div class="flex justify-between items-center mb-5">
                            <h3 class="text-3xl font-bold text-cyan-600">Grupo ${groupIndex + 1}</h3>
                        </div>
                        <div class="space-y-4 mb-6">${matchesHtml}</div>
                        <div>
                            <h4 class="text-xl font-semibold mb-3 text-gray-800">Ranking do Grupo</h4>
                            <table class="w-full text-left">
                                <thead>
                                    <tr class="bg-amber-100">
                                        <th class="p-3 rounded-l-lg text-base text-gray-600">Pos.</th>
                                        <th class="p-3 text-base text-gray-600">Jogador</th>
                                        <th class="p-3 rounded-r-lg text-base text-gray-600">Games Vencidos</th>
                                    </tr>
                                </thead>
                                <tbody>${rankingsHtml}</tbody>
                            </table>
                            <div class="flex justify-between mt-2 text-base">
                                <span class="text-emerald-600">‚ñ≤ Dupla Ouro ü•á</span>
                                <span class="text-orange-600">‚ñº Dupla Prata ü•à</span>
                            </div>
                        </div>
                    </div>
                    `;
                }).join('');

                return groupsHtml; // Retorna a string de cards diretamente
            };

            // (TEL√ÉO) -- Sub-tela: Chaves (Mata-Mata) (Read-Only) --
            const renderKnockoutView_ReadOnly = (isFinished) => {
                // Chamadas de renderBracket_ReadOnly sem o √≠cone nos par√¢metros (apenas o t√≠tulo)
                const goldHtml = renderBracket_ReadOnly('S√©rie Ouro ü•á', activeChampionship.goldBracket, 'goldBracket', isFinished);
                const silverHtml = renderBracket_ReadOnly('S√©rie Prata ü•à', activeChampionship.silverBracket, 'silverBracket', isFinished);

                let coveiroHtml = '';
                if (activeChampionship.groups && activeChampionship.groups.length > 0) {
                    const stats = getGlobalTournamentStats(activeChampionship);

                    if (stats.length > 0) {
                        const minGames = stats[0].gamesWon;
                        const coveiros = stats.filter(p => p.gamesWon === minGames);
                        const coveiroNames = coveiros.map(c => c.name).join(' / ');

                        coveiroHtml = `
                        <div class="bg-white text-gray-800 p-6 rounded-lg shadow-xl text-center animate-fade-in w-full sm:max-w-sm border border-gray-200">
                            <h4 class="text-2xl font-black uppercase tracking-wider text-rose-600">üëª Pr√™mio Coveiro</h4>
                            <p class="text-4xl font-extrabold text-gray-900 mt-2">${coveiroNames}</p>
                            <p class="text-sm text-gray-500">Com apenas ${minGames} games marcados no torneio.</p>
                        </div>
                        `;
                    }
                }

                return goldHtml + silverHtml + coveiroHtml; // Retorna a string de cards diretamente
            };

            // (TEL√ÉO) -- Helper: Renderiza uma Chave (Bracket) (Read-Only) --
            const renderBracket_ReadOnly = (title, bracket, bracketType, isFinished) => {
                const rounds = {};
                if (!bracket || bracket.length === 0) {
                     return `<div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 mb-8 w-full sm:max-w-sm border border-gray-200">
                         <h3 class="text-3xl font-bold mb-6 text-cyan-600">
                             ${title}
                         </h3>
                         <p class="text-gray-500">Chave ainda n√£o gerada.</p>
                      </div>`;
                }

                bracket.forEach(match => {
                    if (!rounds[match.round]) rounds[match.round] = [];
                    rounds[match.round].push(match);
                });

                const maxRound = Math.max(...bracket.map(m => m.round));
                const final = bracket.find(m => m.round === maxRound);
                const champion = final?.winner; 

                const isGold = bracketType === 'goldBracket';
                // Fundo do Card de Campe√£o
                const cardStyle = isGold 
                    ? 'bg-gradient-to-r from-yellow-300 via-orange-400 to-orange-500 text-white' // Gold/Orange Style
                    : 'bg-gradient-to-r from-gray-300 via-gray-400 to-gray-500 text-gray-900'; // Silver Style

                // Destaque do Nome do Campe√£o
                const championNameStyle = isGold ? 'text-4xl font-extrabold text-white' : 'text-4xl font-extrabold text-gray-800';

                const championHtml = champion ? `
                <div class="${cardStyle} p-6 rounded-lg shadow-2xl mb-8 text-center animate-fade-in">
                    <h4 class="text-xl font-black uppercase tracking-wider ${isGold ? 'text-white' : 'text-gray-800'}">Campe√µes</h4>
                    <p class="${championNameStyle}">${champion.name}</p>
                </div>
                ` : '';

                const roundsHtml = Object.keys(rounds).sort((a,b) => a-b).map(roundNum => {
                    const roundTitle = Number(roundNum) === maxRound ? 'Final'
                        : Number(roundNum) === maxRound - 1 ? 'Semi-Final'
                        : Number(roundNum) === maxRound - 2 ? 'Quartas de Final'
                        : `Rodada ${roundNum}`;

                    const matchesHtml = rounds[roundNum].map(match => {
                        const pair1 = match.pairs[0]; 
                        const pair2 = match.pairs[1]; 

                        // ==================================================
                        // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                        // ==================================================
                        const p1_isBye = pair1 && pair1.id === 'BYE';
                        const p2_isBye = pair2 && pair2.id === 'BYE';
                        // ==================================================
                        // === FIM DA ALTERA√á√ÉO (BYE) ===
                        // ==================================================

                        const isPair1Winner = match.winner && pair1 && match.winner.id === pair1.id;
                        const isPair2Winner = match.winner && pair2 && match.winner.id === pair2.id;
                        const score1 = match.score[0];
                        const score2 = match.score[1];

                        const winnerClass1 = isPair1Winner ? 'text-emerald-600 font-bold' : (p1_isBye ? 'text-gray-400 italic' : 'text-gray-800');
                        const winnerClass2 = isPair2Winner ? 'text-emerald-600 font-bold' : (p2_isBye ? 'text-gray-400 italic' : 'text-gray-800');

                        // ALTERA√á√ÉO (BYE): Define o nome a ser exibido
                        const pair1Name = p1_isBye ? '--- BYE ---' : (pair1 ? pair1.name : 'Aguardando...');
                        const pair2Name = p2_isBye ? '--- BYE ---' : (pair2 ? pair2.name : 'Aguardando...');

                        return `
                        <div class="bg-amber-100 rounded-lg shadow-sm border border-amber-200 p-4">
                            <div class="flex justify-between items-center mb-2">
                                <span class="font-medium text-lg ${winnerClass1}">
                                    ${pair1Name}
                                </span>
                                <span class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-xl font-bold opacity-70">
                                    ${score1 === null ? '-' : score1}
                                </span>
                            </div>
                            
                            <div class="flex items-center my-2">
                                <div class="flex-grow border-t border-gray-300"></div>
                                <span class="mx-2 text-sm text-gray-500">vs</span>
                                <div class="flex-grow border-t border-gray-300"></div>
                            </div>

                            <div class="flex justify-between items-center">
                                <span class="font-medium text-lg ${winnerClass2}">
                                    ${pair2Name}
                                </span>
                                <span class="w-16 bg-white border border-gray-300 text-gray-800 rounded-lg p-2 text-center text-xl font-bold opacity-70">
                                    ${score2 === null ? '-' : score2}
                                </span>
                            </div>
                        </div>
                        `;
                    }).join('');

                    return `
                    <div class="flex flex-col space-y-6 w-full max-w-xs">
                        <h4 class="text-xl font-semibold text-gray-800">${roundTitle}</h4>
                        ${matchesHtml}
                    </div>
                    `;
                }).join('');

                return `
                <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 mb-8 w-full sm:max-w-sm border border-gray-200">
                    <h3 class="text-3xl font-bold mb-6 text-cyan-600">
                        ${title}
                    </h3>
                    ${championHtml}
                    <div class="flex flex-wrap justify-center gap-4 sm:gap-6 pb-4">
                        ${roundsHtml}
                    </div>
                </div>
                `;
            };


            /* =============================================================================
               L√≥gica do Campeonato Ativo (A√ß√µes de Admin)
               ============================================================================= */

            // (ADMIN) -- Abrir o Tel√£o
            const handleLaunchTelao = () => {
                const champId = appState.currentChampionshipId;
                if (!champId) {
                    showModal("Erro", "ID do campeonato n√£o encontrado.");
                    return;
                }

                // Constr√≥i a URL para o modo tel√£o
                const url = `${window.location.origin}${window.location.pathname}?telao=true&champId=${champId}`;

                // Abre em uma nova aba
                window.open(url, '_blank');
            };

            const handleAddNewPlayerToChampionship = async (e) => {
                e.preventDefault();
                const input = document.getElementById('new-player-name-input');
                const button = document.getElementById('add-new-player-btn');
                const playerName = input.value.trim();
                if (!playerName) return;

                // 1. VERIFICA DUPLICIDADE NO RANKING (OPCIONAL, J√Å FEITO)
                const existingPlayerInRanking = globalPlayers.find(p => p.name.toLowerCase() === playerName.toLowerCase());
                if (existingPlayerInRanking) {
                    showModal("Jogador J√° Existe", `Um jogador chamado "${playerName}" j√° existe no ranking. Use o menu "Adicionar do Ranking" para adicion√°-lo.`);
                    return;
                }

                // 2. VERIFICA DUPLICIDADE NO TORNEIO ATUAL (NOVO REQUISITO)
                const alreadyInTournament = activeChampionship.players.some(
                    p => p.name.toLowerCase() === playerName.toLowerCase()
                );
                if (alreadyInTournament) {
                    showModal("Duplicidade Detectada", `O jogador "${playerName}" j√° est√° inscrito neste torneio.`);
                    return;
                }

                button.disabled = true;

                const newPlayer = {
                    id: crypto.randomUUID(), // Novo ID, pois √© um novo jogador
                    name: playerName
                };

                const newChampData = {
                    ...activeChampionship,
                    players: [...activeChampionship.players, newPlayer]
                };

                await saveActiveChampionship(newChampData);

                input.value = '';
                button.disabled = false;
            };

            const handleAddExistingPlayerToChampionship = async (e) => {
                e.preventDefault();
                const select = document.getElementById('existing-player-select');
                const button = document.getElementById('add-existing-player-btn');
                const playerId = select.value;

                if (!playerId) {
                    showModal("Erro", "Nenhum jogador selecionado.");
                    return;
                }

                const player = globalPlayers.find(p => p.id === playerId);
                if (!player) {
                    showModal("Erro", "Jogador n√£o encontrado. Tente atualizar a p√°gina.");
                    return;
                }

                // NOVO REQUISITO: Verifica se o ID j√° est√° no torneio
                const alreadyInTournament = activeChampionship.players.some(
                    p => p.id === playerId
                );
                if (alreadyInTournament) {
                    showModal("Duplicidade Detectada", `O jogador "${player.name}" j√° est√° inscrito neste torneio.`);
                    return;
                }


                button.disabled = true;

                const newChampData = {
                    ...activeChampionship,
                    players: [...activeChampionship.players, { id: player.id, name: player.name }]
                };

                await saveActiveChampionship(newChampData);

                button.disabled = false;
            };

            const handleDeletePlayerFromChampionship = async (playerId) => {
                if (!confirm("Tem certeza que deseja remover este jogador DO TORNEIO?")) return;

                const newChampData = {
                    ...activeChampionship,
                    players: activeChampionship.players.filter(p => p.id !== playerId)
                };
                await saveActiveChampionship(newChampData);
            };

            // ==========================================================
            // === FUN√á√ÉO ATUALIZADA (CABE√áAS DE CHAVE) ===
            // ==========================================================
            const handleGenerateChampionship = async () => {
                const playerCount = activeChampionship.players.length;
                const isMultypleOfFour = playerCount % 4 === 0;

                if (playerCount < 4 || !isMultypleOfFour) {
                    showModal("N√∫mero de Jogadores Inv√°lido", `O campeonato requer um n√∫mero de jogadores m√∫ltiplo de 4 para grupos de 4 (ex: 4, 8, 12...). Voc√™ tem ${playerCount}.`);
                    return;
                }
                
                const numGroups = playerCount / 4;
                const numDuplas = numGroups * 2; // (jogadores/4 grupos) * 2 duplas por grupo
                
                // ==================================================
                // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                // REMOVE a valida√ß√£o de pot√™ncia de 2
                // ==================================================
                /* if (![2, 4, 8, 16, 32].includes(numDuplas)) {
                     showModal("Regra da Chave", `A regra atual de mata-mata s√≥ suporta 2, 4, 8, 16 ou 32 duplas. Com ${playerCount} jogadores, voc√™ ter√° ${numDuplas} duplas. Por favor, ajuste o n√∫mero de jogadores (ex: 8 ou 16 jogadores).`);
                     return;
                }
                */
                // ==================================================
                // === FIM DA ALTERA√á√ÉO (BYE) ===
                // ==================================================


                // === NOVA L√ìGICA DE CABE√áA DE CHAVE ===
                if (!confirm(`Iniciar grupos com ${playerCount} jogadores? Os ${numGroups} melhores do ranking ser√£o os "Cabe√ßas de Chave" e o restante ser√° sorteado.`)) {
                    return;
                }

                try {
                    // 1. Mapear pontos do ranking global aos jogadores do torneio
                    const globalPlayersMap = new Map(globalPlayers.map(p => [p.id, p.points || 0]));

                    const tournamentPlayersWithPoints = activeChampionship.players.map(p => ({
                        ...p, // id, name
                        points: globalPlayersMap.get(p.id) || 0 // Pega pontos do ranking, 0 se for jogador novo
                    }));

                    // 2. Ordenar jogadores do torneio por pontos
                    const sortedTournamentPlayers = tournamentPlayersWithPoints.sort((a, b) => b.points - a.points);

                    // 3. Separar Cabe√ßas de Chave dos demais
                    const seededPlayers = sortedTournamentPlayers.slice(0, numGroups);
                    const unseededPlayers = sortedTournamentPlayers.slice(numGroups);

                    // 4. Embaralhar os "n√£o-cabe√ßas"
                    const shuffledUnseeded = unseededPlayers.sort(() => 0.5 - Math.random());

                    // 5. Criar os grupos "esqueleto"
                    const newGroupsList = []; // Esta ser√° a lista final
                    for (let i = 0; i < numGroups; i++) {
                        newGroupsList.push({
                            id: `group_${i + 1}`,
                            players: [], // Come√ßa vazio
                            matches: []  // Come√ßa vazio
                        });
                    }

                    // 6. Distribuir Cabe√ßas de Chave (1 por grupo)
                    for (let i = 0; i < seededPlayers.length; i++) {
                        newGroupsList[i].players.push(seededPlayers[i]);
                    }

                    // 7. Distribuir os demais (distribui√ß√£o "snake" para equilibrar)
                    let unseededCursor = 0;
                    const playersPerGroup = 4;
                    for (let p_slot = 1; p_slot < playersPerGroup; p_slot++) { // Come√ßa do slot 1 (o 0 √© do cabe√ßa)
                        for (let g_index = 0; g_index < numGroups; g_index++) { // Itera nos grupos
                            if (unseededCursor < shuffledUnseeded.length) {
                                newGroupsList[g_index].players.push(shuffledUnseeded[unseededCursor]);
                                unseededCursor++;
                            }
                        }
                    }

                    // 8. Agora que os groups.players est√£o definidos, criar as 'matches'
                    for (const group of newGroupsList) {
                        const [p1, p2, p3, p4] = group.players; 
                        
                        if (!p1 || !p2 || !p3 || !p4) {
                             console.error("Erro na distribui√ß√£o de grupos. Grupo incompleto:", group.players);
                             throw new Error("Erro de l√≥gica ao distribuir jogadores. Grupo ficou incompleto.");
                        }

                        group.matches = [
                            { id: 1, p: [p1.id, p2.id, p3.id, p4.id], names: [`${p1.name} / ${p2.name}`, `${p3.name} / ${p4.name}`], score: [null, null] },
                            { id: 2, p: [p1.id, p3.id, p2.id, p4.id], names: [`${p1.name} / ${p3.name}`, `${p2.name} / ${p4.name}`], score: [null, null] },
                            { id: 3, p: [p1.id, p4.id, p2.id, p3.id], names: [`${p1.name} / ${p4.name}`, `${p2.name} / ${p3.name}`], score: [null, null] },
                        ];
                    }
                    
                    // 9. Salvar no banco
                    const newChampData = {
                        ...activeChampionship,
                        status: 'groups',
                        groups: newGroupsList // Salva a nova lista de grupos
                    };
                    await saveActiveChampionship(newChampData);

                    // 10. Atualizar status principal
                    const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                    await setDoc(champRef, { status: 'groups' }, { merge: true });

                } catch (error) {
                    console.error("Erro ao gerar campeonato (cabe√ßa de chave):", error);
                    showModal("Erro", "N√£o foi poss√≠vel gerar os grupos. " + error.message);
                }
            };

            // =================================================================
            // === NOVAS FUN√á√ïES DE EDI√á√ÉO DE PLACAR ===
            // =================================================================
            
            // (Handler do Bot√£o ‚úèÔ∏è)
            const handleEditGroupScore = (groupIndex, matchIndex) => {
                const champInfo = championships.find(c => c.id === appState.currentChampionshipId);
                const isFinished = champInfo?.status === 'finished';

                if (!isFinished) {
                    // Se o torneio n√£o acabou, s√≥ salva (mesma l√≥gica do bot√£o "confirmar")
                    handleConfirmGroupScore(groupIndex, matchIndex);
                    return;
                }

                // Se o torneio J√Å ACABOU, pede confirma√ß√£o
                const val0 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s0`).value;
                const val1 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s1`).value;
                const score0 = val0 === '' ? null : parseInt(val0, 10);
                const score1 = val1 === '' ? null : parseInt(val1, 10);

                if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                    showModal("Placar Inv√°lido", "Ambos os placares devem ser preenchidos com n√∫meros positivos (ou 0).");
                    return;
                }

                const confirmationButtons = [
                    {
                        id: 'modal-cancel-btn',
                        text: 'Cancelar',
                        className: 'w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 px-5 rounded-lg shadow-sm transition-all',
                        handler: hideModal
                    },
                    {
                        id: 'modal-confirm-edit-btn',
                        text: 'Confirmar e Recalcular',
                        className: 'w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 px-5 rounded-lg shadow-lg transition-all',
                        handler: () => {
                            // Salva a edi√ß√£o e dispara o rec√°lculo do ranking
                            handleConfirmGroupScore_Logic(groupIndex, matchIndex, score0, score1, true); // true = for√ßar rec√°lculo
                            hideModal();
                        }
                    }
                ];

                showModal(
                    "Aten√ß√£o: Torneio Finalizado", 
                    "Voc√™ est√° editando o placar de um torneio que j√° foi finalizado. Isso ir√° recalcular os vencedores e ajustar o Ranking Global.<br><br>Deseja continuar?",
                    confirmationButtons
                );
            };
            
            // (Handler do Bot√£o ‚úÖ)
            const handleConfirmGroupScore = (groupIndex, matchIndex) => {
                const val0 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s0`).value;
                const val1 = document.getElementById(`g-${groupIndex}-m-${matchIndex}-s1`).value;

                const score0 = val0 === '' ? null : parseInt(val0, 10);
                const score1 = val1 === '' ? null : parseInt(val1, 10);

                if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                    showModal("Placar Inv√°lido", "Ambos os placares devem ser preenchidos com n√∫meros positivos (ou 0).");
                    return;
                }
                
                // Apenas salva, sem for√ßar rec√°lculo
                handleConfirmGroupScore_Logic(groupIndex, matchIndex, score0, score1, false);
            };

            // (Fun√ß√£o L√≥gica)
            const handleConfirmGroupScore_Logic = async (groupIndex, matchIndex, score0, score1, forceRecalculate) => {
                const newChampData = JSON.parse(JSON.stringify(activeChampionship));
                newChampData.groups[groupIndex].matches[matchIndex].score[0] = score0;
                newChampData.groups[groupIndex].matches[matchIndex].score[1] = score1;

                // Se a edi√ß√£o for em um torneio finalizado, precisamos recalcular o mata-mata
                if (forceRecalculate) {
                    // 1. Recalcula os classificados
                    let goldSeriesPairs = [];
                    let silverSeriesPairs = [];

                    newChampData.groups.forEach(group => {
                        const rankings = getRankings(group); // Recalcula com o novo placar
                        goldSeriesPairs.push({ id: `${rankings[0].id}_${rankings[1].id}`, name: `${rankings[0].name} / ${rankings[1].name}`, players: [rankings[0], rankings[1]] });
                        silverSeriesPairs.push({ id: `${rankings[2].id}_${rankings[3].id}`, name: `${rankings[2].name} / ${rankings[3].name}`, players: [rankings[2], rankings[3]] });
                    });
                    
                    // 2. Recria as chaves (com o mesmo sorteio, se poss√≠vel - mas aqui estamos recriando)
                    //    NOTA: Isso ir√° resetar o mata-mata. Uma l√≥gica mais complexa
                    //    manteria os placares antigos se os times fossem os mesmos.
                    //    Para v1 da Edi√ß√£o: Resetar o mata-mata √© aceit√°vel.
                    
                    // ==================================================
                    // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                    // Aplica a l√≥gica de Bye na recria√ß√£o da chave
                    // ==================================================
                    const finalGoldPairs = addByes(goldSeriesPairs);
                    const finalSilverPairs = addByes(silverSeriesPairs);

                    let goldBracket = createBracket(finalGoldPairs);
                    let silverBracket = createBracket(finalSilverPairs);

                    goldBracket = advanceByes(goldBracket);
                    silverBracket = advanceByes(silverBracket);
                    // ==================================================
                    // === FIM DA ALTERA√á√ÉO (BYE) ===
                    // ==================================================

                    newChampData.status = 'knockout'; // Volta o status para poder preencher de novo
                    newChampData.goldBracket = goldBracket;
                    newChampData.silverBracket = silverBracket;
                    
                    // Limpa os dados de finaliza√ß√£o no doc principal
                    const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                    await setDoc(champRef, { status: 'knockout', winnerGold: null, winnerSilver: null }, { merge: true });
                    
                    showModal("Mata-Mata Resetado", "O placar do grupo foi alterado. O mata-mata foi resetado. Por favor, preencha os placares das chaves novamente.");
                }

                await saveActiveChampionship(newChampData);
            };


            const handlePrintGroup = (groupIndex) => {
                const group = activeChampionship.groups[groupIndex];
                const champ = championships.find(c => c.id === appState.currentChampionshipId);
                const champName = champ ? champ.name : "Torneio";

                let matchesHtml = '';
                group.matches.forEach((match, index) => {
                    matchesHtml += `
                        <div class="match">
                            <div class="team">${match.names[0]}</div>
                            <div class="score-box"></div>
                            <div class="vs">vs</div>
                            <div class="score-box"></div>
                            <div class="team">${match.names[1]}</div>
                        </div>
                    `;
                });

                const playersHtml = group.players.map(p => `<li>${p.name}</li>`).join('');

                const printStyles = `
                    <style>
                        @page { margin: 20mm; }
                        body { 
                            font-family: Arial, sans-serif; 
                            margin: 0; 
                            color: #000; 
                            width: 100%;
                        }
                        h1 { text-align: center; font-size: 24px; margin-bottom: 5px; }
                        h2 { text-align: center; font-size: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; margin-top: 0; }
                        .players { margin-bottom: 20px; }
                        .players h3 { font-size: 18px; margin-bottom: 5px; }
                        .players ul { list-style: none; padding-left: 0; margin: 0; }
                        .players li { font-size: 16px; }
                        .match { 
                            display: flex; 
                            align-items: center; 
                            justify-content: space-between; 
                            padding: 20px 0; 
                            border-bottom: 1px dashed #999; 
                            page-break-inside: avoid;
                        }
                        .team { flex: 1; font-size: 18px; font-weight: bold; }
                        .team:last-of-type { text-align: right; }
                        .vs { font-size: 14px; font-weight: bold; margin: 0 10px; }
                        .score-box {
                            width: 60px;
                            height: 40px;
                            border: 2px solid #000;
                            margin: 0 10px;
                        }
                    </style>
                `;

                const printWindow = window.open('', '_blank', 'width=800,height=600');
                printWindow.document.write(`
                    <html>
                        <head>
                            <title>Imprimir - ${champName} - Grupo ${groupIndex + 1}</title>
                            ${printStyles}
                        </head>
                        <body>
                            <h1>${champName}</h1>
                            <h2>Grupo ${groupIndex + 1}</h2>
                            <div class="players">
                                <h3>Jogadores do Grupo:</h3>
                                <ul>${playersHtml}</ul>
                            </div>
                            <h2>Jogos</h2>
                            <div class="matches">
                                ${matchesHtml}
                            </div>
                        </body>
                    </html>
                `);
                printWindow.document.close();
                printWindow.focus();

                // Um pequeno delay para garantir que o DOM esteja pronto antes de imprimir
                setTimeout(() => {
                    printWindow.print();
                }, 250);
            };

            const handleFinalizeGroups = async () => {
                if (!confirm("Finalizar Fase de Grupos? Isso ir√° gerar as chaves Ouro e Prata e bloquear os grupos.")) return;

                let goldSeriesPairs = [];
                let silverSeriesPairs = [];

                activeChampionship.groups.forEach(group => {
                    const rankings = getRankings(group); // [p1, p2, p3, p4]

                    const goldPair = {
                        id: `${rankings[0].id}_${rankings[1].id}`,
                        name: `${rankings[0].name} / ${rankings[1].name}`,
                        players: [rankings[0], rankings[1]] 
                    };
                    goldSeriesPairs.push(goldPair);

                    const silverPair = {
                        id: `${rankings[2].id}_${rankings[3].id}`,
                        name: `${rankings[2].name} / ${rankings[3].name}`,
                        players: [rankings[2], rankings[3]]
                    };
                    silverSeriesPairs.push(silverPair);
                });

                // ==================================================
                // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                // REMOVE a valida√ß√£o de pot√™ncia de 2
                // ==================================================
                /*
                if (![2, 4, 8, 16, 32].includes(goldSeriesPairs.length) || ![2, 4, 8, 16, 32].includes(silverSeriesPairs.length)) {
                     showModal("Erro de Gera√ß√£o", `A regra atual de mata-mata (sem Byes) exige que o n√∫mero de duplas seja 2, 4, 8, 16 ou 32. Chave Ouro tem ${goldSeriesPairs.length} e Prata tem ${silverSeriesPairs.length}. Ajuste o n√∫mero de jogadores antes de finalizar.`);
                     return;
                }
                */
                // ==================================================
                // === FIM DA ALTERA√á√ÉO (BYE) ===
                // ==================================================

                try {
                    // ==================================================
                    // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                    // Adiciona as 3 etapas: addByes, createBracket, advanceByes
                    // ==================================================
                    
                    // 1. Adiciona Byes para preencher as chaves
                    const finalGoldPairs = addByes(goldSeriesPairs);
                    const finalSilverPairs = addByes(silverSeriesPairs);

                    // 2. Cria as chaves (agora com tamanho de pot√™ncia de 2)
                    let goldBracket = createBracket(finalGoldPairs);
                    let silverBracket = createBracket(finalSilverPairs);
                    
                    // 3. Avan√ßa automaticamente os vencedores contra Byes (e define placar 6x0)
                    goldBracket = advanceByes(goldBracket);
                    silverBracket = advanceByes(silverBracket);
                    // ==================================================
                    // === FIM DA ALTERA√á√ÉO (BYE) ===
                    // ==================================================

                    const newChampData = {
                        ...activeChampionship,
                        status: 'knockout',
                        goldBracket: goldBracket, // Salva a chave processada
                        silverBracket: silverBracket, // Salva a chave processada
                    };

                    await saveActiveChampionship(newChampData);

                    const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                    await setDoc(champRef, { status: 'knockout' }, { merge: true });

                } catch (error) {
                    console.error("Erro ao finalizar grupos:", error);
                    showModal("Erro", "Ocorreu um erro ao gerar as chaves.");
                }
            };

            // (Handler do Bot√£o ‚úèÔ∏è)
            const handleEditKnockoutScore = (bracketType, matchId) => {
                const champInfo = championships.find(c => c.id === appState.currentChampionshipId);
                const isFinished = champInfo?.status === 'finished';

                if (!isFinished) {
                    // Se o torneio n√£o acabou, s√≥ salva (mesma l√≥gica do bot√£o "confirmar")
                    handleConfirmKnockoutScore(bracketType, matchId);
                    return;
                }
                
                // Se o torneio J√Å ACABOU, pede confirma√ß√£o
                const val0 = document.getElementById(`k-${matchId}-s0`).value;
                const val1 = document.getElementById(`k-${matchId}-s1`).value;
                const score0 = val0 === '' ? null : parseInt(val0, 10);
                const score1 = val1 === '' ? null : parseInt(val1, 10);

                if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                    showModal("Placar Inv√°lido", "Ambos os placares devem ser preenchidos com n√∫meros positivos (ou 0).");
                    return;
                }
                if (score0 === score1) {
                    showModal("Placar Inv√°lido", "O placar do mata-mata n√£o pode ser um empate.");
                    return;
                }
                
                const confirmationButtons = [
                    {
                        id: 'modal-cancel-btn',
                        text: 'Cancelar',
                        className: 'w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 px-5 rounded-lg shadow-sm transition-all',
                        handler: hideModal
                    },
                    {
                        id: 'modal-confirm-edit-btn',
                        text: 'Confirmar e Recalcular',
                        className: 'w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 px-5 rounded-lg shadow-lg transition-all',
                        handler: () => {
                            // Salva a edi√ß√£o e dispara o rec√°lculo do ranking
                            handleConfirmKnockoutScore_Logic(bracketType, matchId, score0, score1, true); // true = for√ßar rec√°lculo
                            hideModal();
                        }
                    }
                ];

                showModal(
                    "Aten√ß√£o: Torneio Finalizado", 
                    "Voc√™ est√° editando o placar de um torneio que j√° foi finalizado. Isso ir√° recalcular os vencedores e ajustar o Ranking Global.<br><br>Deseja continuar?",
                    confirmationButtons
                );
            };
            
            // (Handler do Bot√£o ‚úÖ)
            const handleConfirmKnockoutScore = (bracketType, matchId) => {
                const val0 = document.getElementById(`k-${matchId}-s0`).value;
                const val1 = document.getElementById(`k-${matchId}-s1`).value;

                const score0 = val0 === '' ? null : parseInt(val0, 10);
                const score1 = val1 === '' ? null : parseInt(val1, 10);

                if (score0 === null || score1 === null || isNaN(score0) || isNaN(score1) || score0 < 0 || score1 < 0) {
                    showModal("Placar Inv√°lido", "Ambos os placares devem ser preenchidos com n√∫meros positivos (ou 0).");
                    return;
                }
                if (score0 === score1) {
                    showModal("Placar Inv√°lido", "O placar do mata-mata n√£o pode ser um empate.");
                    return;
                }
                
                // Apenas salva, sem for√ßar rec√°lculo
                handleConfirmKnockoutScore_Logic(bracketType, matchId, score0, score1, false);
            };

            // (Fun√ß√£o L√≥gica)
            const handleConfirmKnockoutScore_Logic = async (bracketType, matchId, score0, score1, forceRecalculate) => {
                const newChampData = JSON.parse(JSON.stringify(activeChampionship));
                const bracketToUpdate = newChampData[bracketType];
                const match = bracketToUpdate.find(m => m.id === matchId);

                if (match) {
                    match.score[0] = score0;
                    match.score[1] = score1;
                    
                    // Determina o vencedor
                    let winner = null;
                    if (score0 > score1) winner = match.pairs[0]; 
                    else if (score1 > score0) winner = match.pairs[1];
                    
                    // Se o vencedor mudou, reseta as pr√≥ximas chaves
                    if (match.winner && winner && match.winner.id !== winner.id) {
                        let currentMatch = match;
                        while (currentMatch && currentMatch.nextMatchId) {
                            const nextMatch = bracketToUpdate.find(m => m.id === currentMatch.nextMatchId);
                            if (nextMatch) {
                                nextMatch.pairs[currentMatch.nextMatchSlot] = null;
                                nextMatch.score = [null, null];
                                nextMatch.winner = null;
                                currentMatch = nextMatch;
                            } else {
                                currentMatch = null;
                            }
                        }
                    }
                    
                    match.winner = winner;

                    // Avan√ßa o novo vencedor
                    if (match.winner && match.nextMatchId) {
                        const nextMatch = bracketToUpdate.find(m => m.id === match.nextMatchId);
                        if (nextMatch) nextMatch.pairs[match.nextMatchSlot] = match.winner;
                    }

                    await saveActiveChampionship(newChampData); 
                    
                    // Verifica se o torneio acabou (ou se estamos for√ßando o rec√°lculo)
                    const finalizationCheckData = await checkAndFinalizeChampionship(newChampData, forceRecalculate);
                    
                    // Se o checkAndFinalize rodou por causa de uma edi√ß√£o (forceRecalculate)
                    // E ele retornou os dados de diff, aplicamos
                    if (forceRecalculate && finalizationCheckData && finalizationCheckData.didRecalculate) {
                        const { diffMap, rankingId } = finalizationCheckData;
                        await applyRankingDiff(diffMap, rankingId);
                        showModal("Sucesso!", "O placar foi corrigido e o Ranking Global foi ajustado com a diferen√ßa de pontos.");
                    }
                }
            };


            /* =============================================================================
               L√≥gica de C√°lculo de Ranking (ATUALIZADA)
               ============================================================================= */

            const checkAndFinalizeChampionship = async (champData, forceRecalculate = false) => {
                if (!champData.goldBracket || !champData.silverBracket || champData.goldBracket.length === 0 || champData.silverBracket.length === 0) {
                    return { didRecalculate: false }; 
                }

                const maxRoundGold = Math.max(...champData.goldBracket.map(m => m.round));
                const maxRoundSilver = Math.max(...champData.silverBracket.map(m => m.round));

                const goldFinal = champData.goldBracket.find(m => m.round === maxRoundGold);
                const silverFinal = champData.silverBracket.find(m => m.round === maxRoundSilver);

                const goldWinner = goldFinal?.winner; 
                const silverWinner = silverFinal?.winner; 

                // S√≥ continua se o torneio estiver finalizado (ambas as chaves t√™m campe√£o)
                if (goldWinner && silverWinner) {
                    
                    const champRef = doc(db, 'users', appState.userId, 'championships', appState.currentChampionshipId);
                    const champDoc = await getDoc(champRef);
                    if (!champDoc.exists()) return { didRecalculate: false }; 

                    const champDocData = champDoc.data();
                    const rankingId = champDocData.rankingId;
                    if (!rankingId) {
                        showModal("Erro Cr√≠tico", "Este campeonato n√£o est√° vinculado a nenhum ranking. Os pontos n√£o podem ser salvos.");
                        return { didRecalculate: false };
                    }

                    // Pega o "snapshot" de pontos antigos (se houver)
                    const oldPointsMap = champDocData.finalPointsAwarded || null;
                    const effectivePoints = champDocData.pointsConfig || DEFAULT_RANKING_POINTS;
                    
                    // 1. CALCULA O NOVO ESTADO
                    const { newPointsMap, newWinners } = calculatePlayerPointsMap(champData, effectivePoints);

                    // 2. SALVA O NOVO ESTADO (Status, Vencedores e o novo Snapshot de Pontos)
                    await setDoc(champRef, {
                        status: 'finished',
                        winnerGold: newWinners.goldWinner.name, 
                        winnerSilver: newWinners.silverWinner.name,
                        finalPointsAwarded: newPointsMap // Salva o novo snapshot
                    }, { merge: true });

                    // 3. APLICA A L√ìGICA DE RANKING
                    try {
                        if (oldPointsMap) {
                            // J√Å FOI FINALIZADO (√â UMA EDI√á√ÉO)
                            // Calcula a diferen√ßa (diff) entre o novo e o antigo
                            const diffMap = new Map();
                            
                            // Combina todas as chaves (IDs) de ambos os mapas
                            const allPlayerIds = new Set([...Object.keys(oldPointsMap), ...Object.keys(newPointsMap)]);

                            allPlayerIds.forEach(id => {
                                const oldP = oldPointsMap[id] || { points: 0, goldWins: 0, silverWins: 0, coveiroWins: 0 };
                                const newP = newPointsMap[id] || { points: 0, goldWins: 0, silverWins: 0, coveiroWins: 0 };
                                
                                const diff = {
                                    points: newP.points - oldP.points,
                                    goldWins: newP.goldWins - oldP.goldWins,
                                    silverWins: newP.silverWins - oldP.silverWins,
                                    coveiroWins: newP.coveiroWins - oldP.coveiroWins
                                };

                                // S√≥ adiciona se houver diferen√ßa
                                if (diff.points !== 0 || diff.goldWins !== 0 || diff.silverWins !== 0 || diff.coveiroWins !== 0) {
                                    diffMap.set(id, { name: newP.name || oldP.name, diff }); // Salva o diff
                                }
                            });
                            
                            // Retorna os dados para a fun√ß√£o que chamou (handleConfirmKnockoutScore_Logic)
                            // para que ela possa aplicar o Diff DEPOIS de salvar
                            if (forceRecalculate) {
                                 return { didRecalculate: true, diffMap, rankingId };
                            }

                        } else {
                            // PRIMEIRA VEZ FINALIZANDO
                            showModal("Calculando...", "Finalizando torneio e atualizando o ranking global. Aguarde...");
                            
                            // Aplica os pontos TOTAIS (n√£o √© um diff)
                            await updateGlobalRanking(newPointsMap, rankingId); 
                            
                            hideModal();
                            showModal("Sucesso!", `Ranking global atualizado! ü•á Campe√µes Ouro: ${newWinners.goldWinner.name}. ü•à Campe√µes Prata: ${newWinners.silverWinner.name}.`);
                        }
                    } catch (error) {
                        console.error("Erro ao finalizar e aplicar ranking:", error);
                        showModal("Erro Cr√≠tico", "N√£o foi poss√≠vel aplicar o ranking. Verifique o console.");
                    }
                }
                
                return { didRecalculate: false }; // N√£o recalculou
            };

            // NOVO HELPER: Calcula o mapa de pontos (para ser usado na finaliza√ß√£o e no diff)
            const calculatePlayerPointsMap = (champData, pointsConfig) => {
                const goldFinal = champData.goldBracket.find(m => m.round === Math.max(...champData.goldBracket.map(m => m.round)));
                const silverFinal = champData.silverBracket.find(m => m.round === Math.max(...champData.silverBracket.map(m => m.round)));

                const goldWinner = goldFinal?.winner;
                const goldRunnerUp = goldWinner ? goldFinal.pairs.find(p => p.id !== goldWinner.id) : null;
                const silverWinner = silverFinal?.winner;
                const silverRunnerUp = silverWinner ? silverFinal.pairs.find(p => p.id !== silverWinner.id) : null;

                const stats = getGlobalTournamentStats(champData);
                const minGames = stats.length > 0 ? stats[0].gamesWon : 0;
                const coveiros = stats.length > 0 ? stats.filter(p => p.gamesWon === minGames) : [];

                const winners = { goldWinner, goldRunnerUp, silverWinner, silverRunnerUp, coveiros };
                
                // Converte o Map para um Objeto serializ√°vel
                const playerPointsObject = {}; 

                for (const player of champData.players) {
                    playerPointsObject[player.id] = {
                        name: player.name,
                        points: pointsConfig.participation,
                        goldWins: 0,
                        silverWins: 0,
                        coveiroWins: 0 
                    };
                }
                if (winners.goldWinner) {
                    for (const player of winners.goldWinner.players) {
                        const p = playerPointsObject[player.id];
                        if (p) { p.points += pointsConfig.goldWinner; p.goldWins = 1; }
                    }
                }
                if (winners.goldRunnerUp) {
                    for (const player of winners.goldRunnerUp.players) {
                        const p = playerPointsObject[player.id];
                         if (p) p.points += pointsConfig.goldRunnerUp;
                    }
                }
                if (winners.silverWinner) {
                    for (const player of winners.silverWinner.players) {
                        const p = playerPointsObject[player.id];
                         if (p) { p.points += pointsConfig.silverWinner; p.silverWins = 1; }
                    }
                }
                if (winners.silverRunnerUp) {
                     for (const player of winners.silverRunnerUp.players) {
                        const p = playerPointsObject[player.id];
                         if (p) p.points += pointsConfig.silverRunnerUp;
                    }
                }
                if (winners.coveiros && winners.coveiros.length > 0) {
                    for (const coveiro of winners.coveiros) {
                        const p = playerPointsObject[coveiro.id];
                        if (p) { p.coveiroWins = 1; }
                    }
                }
                
                return { newPointsMap: playerPointsObject, newWinners: winners };
            };

            // (ATUALIZADA: Recebe o Map/Objeto de pontos)
            const updateGlobalRanking = async (playerPointsMap, rankingId) => {
                await runTransaction(db, async (transaction) => {
                    // 1. FASE DE LEITURA
                    const playerDocsData = new Map();
                    for (const playerId in playerPointsMap) {
                        const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId);
                        const playerDoc = await transaction.get(playerRef);
                        playerDocsData.set(playerId, playerDoc); 
                    }

                    // 2. FASE DE ESCRITA
                    for (const playerId in playerPointsMap) {
                        const data = playerPointsMap[playerId];
                        const playerDoc = playerDocsData.get(playerId); 
                        const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId); 

                        if (!playerDoc.exists()) {
                            transaction.set(playerRef, {
                                name: data.name,
                                points: data.points,
                                goldWins: data.goldWins,
                                silverWins: data.silverWins,
                                coveiroWins: data.coveiroWins 
                            });
                        } else {
                            const oldData = playerDoc.data();
                            transaction.update(playerRef, {
                                name: data.name, // Garante que o nome est√° atualizado
                                points: (oldData.points || 0) + data.points,
                                goldWins: (oldData.goldWins || 0) + data.goldWins,
                                silverWins: (oldData.silverWins || 0) + data.silverWins,
                                coveiroWins: (oldData.coveiroWins || 0) + data.coveiroWins 
                            });
                        }
                    }
                });
            };
            
            // (NOVA FUN√á√ÉO: Aplica apenas a diferen√ßa)
            const applyRankingDiff = async (diffMap, rankingId) => {
                await runTransaction(db, async (transaction) => {
                    // 1. FASE DE LEITURA
                    const playerDocsData = new Map();
                    for (const [playerId, data] of diffMap.entries()) {
                        const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId);
                        const playerDoc = await transaction.get(playerRef);
                        playerDocsData.set(playerId, playerDoc); 
                    }

                    // 2. FASE DE ESCRITA
                    for (const [playerId, data] of diffMap.entries()) {
                        const { name, diff } = data;
                        const playerDoc = playerDocsData.get(playerId); 
                        const playerRef = doc(db, 'users', appState.userId, 'rankings', rankingId, 'players', playerId); 

                        if (!playerDoc.exists()) {
                            // Se o jogador n√£o existe, aplicamos o diff como o valor inicial
                            console.warn(`Aplicando diff para jogador ${name} que n√£o existia no ranking.`);
                            transaction.set(playerRef, {
                                name: name,
                                points: diff.points,
                                goldWins: diff.goldWins,
                                silverWins: diff.silverWins,
                                coveiroWins: diff.coveiroWins 
                            });
                        } else {
                            // Se existe, somamos o diff
                            const oldData = playerDoc.data();
                            transaction.update(playerRef, {
                                points: (oldData.points || 0) + diff.points,
                                goldWins: (oldData.goldWins || 0) + diff.goldWins,
                                silverWins: (oldData.silverWins || 0) + diff.silverWins,
                                coveiroWins: (oldData.coveiroWins || 0) + diff.coveiroWins 
                            });
                        }
                    }
                });
            };

            /* =============================================================================
               Fun√ß√µes Utilit√°rias (C√°lculos de Grupos e Chaves)
               ============================================================================= */
            
            // ==================================================
            // === IN√çCIO DAS NOVAS FUN√á√ïES (BYE) ===
            // ==================================================

            /**
             * Adiciona "Byes" a uma lista de duplas para preencher a chave at√© a pr√≥xima pot√™ncia de 2.
             */
            const addByes = (pairs) => {
                const numPairs = pairs.length;
                
                // Se j√° for uma pot√™ncia de 2 (ou 0), n√£o faz nada
                if (numPairs === 0 || (numPairs & (numPairs - 1)) === 0) {
                    return pairs;
                }

                // Calcula a pr√≥xima pot√™ncia de 2
                // Ex: 3 -> log2(3) = 1.58 -> ceil(1.58) = 2 -> 2^2 = 4
                // Ex: 5 -> log2(5) = 2.32 -> ceil(2.32) = 3 -> 2^3 = 8
                const nextPowerOfTwo = Math.pow(2, Math.ceil(Math.log2(numPairs)));
                const numByes = nextPowerOfTwo - numPairs;

                // Cria um objeto "Bye" que a UI possa renderizar
                const byePair = { 
                    id: 'BYE', 
                    name: '--- BYE ---', // Ser√° exibido na chave
                    players: [] // Vazio para n√£o dar erro
                };
                
                const byeArray = Array(numByes).fill(byePair);
                
                // Retorna a lista original + os Byes
                return pairs.concat(byeArray);
            };

            /**
             * Avan√ßa automaticamente os vencedores contra 'Bye' na Rodada 1
             * e define o placar como 6x0 para o 'Coveiro'.
             */
            const advanceByes = (bracket) => {
                if (!bracket || bracket.length === 0) return bracket;

                const round1Matches = bracket.filter(m => m.round === 1);

                for (const match of round1Matches) {
                    const pair1 = match.pairs[0];
                    const pair2 = match.pairs[1];
                    let winner = null;

                    // Verifica se a Dupla 1 joga contra um Bye
                    if (pair1 && pair1.id !== 'BYE' && pair2 && pair2.id === 'BYE') {
                        winner = pair1;
                        match.score = [6, 0]; // Define placar para o Coveiro
                    }
                    // Verifica se a Dupla 2 joga contra um Bye
                    else if (pair2 && pair2.id !== 'BYE' && pair1 && pair1.id === 'BYE') {
                        winner = pair2;
                        match.score = [0, 6]; // Define placar para o Coveiro
                    }

                    // Se encontramos um vencedor por Bye
                    if (winner) {
                        match.winner = winner;
                        
                        // Avan√ßa o vencedor para a pr√≥xima rodada
                        if (match.nextMatchId) {
                            const nextMatch = bracket.find(m => m.id === match.nextMatchId);
                            if (nextMatch) {
                                nextMatch.pairs[match.nextMatchSlot] = winner;
                            }
                        }
                    }
                }
                return bracket; // Retorna a chave modificada
            };
            
            // ==================================================
            // === FIM DAS NOVAS FUN√á√ïES (BYE) ===
            // ==================================================


            const getRankings = (group) => {
                const playerStats = {};
                group.players.forEach(p => {
                    playerStats[p.id] = { id: p.id, name: p.name, gamesWon: 0 };
                });

                group.matches.forEach(match => {
                    const [p1, p2, p3, p4] = match.p;
                    const [s1, s2] = match.score;

                    if (s1 !== null && !isNaN(s1)) {
                        playerStats[p1].gamesWon += s1;
                        playerStats[p2].gamesWon += s1;
                    }
                    if (s2 !== null && !isNaN(s2)) {
                        playerStats[p3].gamesWon += s2;
                        playerStats[p4].gamesWon += s2;
                    }
                });

                return Object.values(playerStats).sort((a, b) => b.gamesWon - a.gamesWon);
            };


            // Calcula o total de games do TORNEIO (Grupos + Mata-Mata)
            // ESTA FUN√á√ÉO N√ÉO PRECISA DE MUDAN√áA (pois advanceByes define o placar [6, 0])
            const getGlobalTournamentStats = (champData) => {
                const playerStats = {};

                // 1. Inicializa todos os jogadores do torneio
                champData.players.forEach(p => {
                    playerStats[p.id] = { id: p.id, name: p.name, gamesWon: 0 };
                });

                // 2. Soma os games da Fase de Grupos
                if (champData.groups) {
                    champData.groups.forEach(group => {
                        group.matches.forEach(match => {
                            const [p1, p2, p3, p4] = match.p;
                            const [s1, s2] = match.score;

                            if (s1 !== null && !isNaN(s1)) {
                                if (playerStats[p1]) playerStats[p1].gamesWon += s1;
                                if (playerStats[p2]) playerStats[p2].gamesWon += s1;
                            }
                            if (s2 !== null && !isNaN(s2)) {
                                if (playerStats[p3]) playerStats[p3].gamesWon += s2;
                                if (playerStats[p4]) playerStats[p4].gamesWon += s2;
                            }
                        });
                    });
                }

                // 3. Soma os games do Mata-Mata (Ouro e Prata)
                const allKnockoutMatches = (champData.goldBracket || []).concat(champData.silverBracket || []);

                allKnockoutMatches.forEach(match => {
                    const [pair1, pair2] = match.pairs;
                    const [s0, s1] = match.score;

                    // N√£o conta jogos de Bye no placar, mas conta a folga como vit√≥ria
                    if (s0 !== null && !isNaN(s0) && pair1 && pair1.players) {
                        pair1.players.forEach(player => {
                            if (playerStats[player.id]) {
                                playerStats[player.id].gamesWon += s0;
                            }
                        });
                    }

                    if (s1 !== null && !isNaN(s1) && pair2 && pair2.players) {
                        pair2.players.forEach(player => {
                            if (playerStats[player.id]) {
                                playerStats[player.id].gamesWon += s1;
                            }
                        });
                    }
                });

                // 4. Retorna a lista ordenada por games (do menor para o maior)
                return Object.values(playerStats).sort((a, b) => a.gamesWon - b.gamesWon);
            };


            // Cria a estrutura de chave de mata-mata (apenas pot√™ncias de 2)
            const createBracket = (bracketPairs) => {
                // Sorteio aleat√≥rio das duplas (cumprindo requisito)
                const shuffledPairs = [...bracketPairs].sort(() => 0.5 - Math.random());
                const bracket = [];
                const numPairs = bracketPairs.length; // Agora ser√° 4, 8, 16... (devido ao addByes)

                // ==================================================
                // === IN√çCIO DA ALTERA√á√ÉO (BYE) ===
                // REMOVE a valida√ß√£o de pot√™ncia de 2
                // ==================================================
                /*
                if (![2, 4, 8, 16, 32].includes(numPairs)) return [];
                */
                // ==================================================
                // === FIM DA ALTERA√á√ÉO (BYE) ===
                // ==================================================


                const numRounds = Math.log2(numPairs); // log2(4) = 2 rodadas

                // Loop crescente (Rodada 1, Rodada 2, ...)
                for (let r = 1; r <= numRounds; r++) { // r=1 (Semi), r=2 (Final)

                    const matchesInRound = numPairs / Math.pow(2, r); 

                    for (let m = 0; m < matchesInRound; m++) { 
                        const matchId = `R${r}_M${m+1}`;
                        let nextMatchId = null;
                        let nextMatchSlot = null; 

                        if (r < numRounds) { // Se n√£o for a rodada final
                            const nextRoundMatchIndex = Math.floor(m / 2); 
                            nextMatchId = `R${r+1}_M${nextRoundMatchIndex+1}`;
                            nextMatchSlot = m % 2; 
                        }

                        const match = {
                            id: matchId,
                            round: r, 
                            pairs: [null, null], 
                            score: [null, null],
                            winner: null,
                            nextMatchId: nextMatchId,
                            nextMatchSlot: nextMatchSlot,
                        };

                        // Preenche a Rodada 1 com as duplas sorteadas
                        if (r === 1) {
                            const index1 = m * 2;
                            const index2 = m * 2 + 1;
                            match.pairs[0] = shuffledPairs[index1] || null;
                            match.pairs[1] = shuffledPairs[index2] || null;
                        }

                        bracket.push(match);
                    }
                }

                return bracket;
            };


            /* =============================================================================
               Fun√ß√µes de PDF
               ============================================================================= */

            const handlePrintRankingPDF = () => {
                // Pega a inst√¢ncia global do jsPDF carregada no <head>
                const { jsPDF } = window.jspdf;
                if (!jsPDF) {
                    showModal("Erro", "Biblioteca PDF (jsPDF) n√£o foi carregada.");
                    return;
                }

                try {
                    const doc = new jsPDF();

                    const currentRanking = allRankings.find(r => r.id === appState.currentRankingId);
                    const rankingName = currentRanking ? currentRanking.name : "Ranking";
                    const title = `Ranking Geral: ${rankingName}`;

                    doc.setFontSize(18);
                    doc.text(title, 105, 22, { align: 'center' }); // Centraliza o t√≠tulo

                    const sortedPlayers = [...globalPlayers].sort((a, b) => b.points - a.points);

                    const head = [['Pos.', 'Jogador', 'Pontos', 'ü•á Ouro', 'ü•à Prata', 'üëª Coveiro']];
                    const body = sortedPlayers.map((p, index) => [
                        `${index + 1}¬∫`,
                        p.name,
                        p.points || 0,
                        p.goldWins || 0,
                        p.silverWins || 0,
                        p.coveiroWins || 0
                    ]);

                    // Usa o plugin autoTable
                    doc.autoTable({
                        startY: 30,
                        head: head,
                        body: body,
                        headStyles: { fillColor: [8, 145, 178] }, // Cor 'Mar' (cyan-600)
                        styles: { halign: 'center', textColor: [31, 41, 55] },
                        headStyles: { fillColor: [254, 243, 199], textColor: [75, 85, 99] }, // Cor 'Areia' (amber-100)
                        columnStyles: {
                            1: { halign: 'left' } // Alinha o nome do jogador √† esquerda
                        }
                    });

                    doc.save(`ranking_${rankingName.toLowerCase().replace(/\s/g, '_')}.pdf`);

                } catch (error) {
                    console.error("Erro ao gerar PDF do ranking:", error);
                    showModal("Erro", "N√£o foi poss√≠vel gerar o PDF. " + error.message);
                }
            };

            const handlePrintChampionshipPDF = () => {
                const { jsPDF } = window.jspdf;
                if (!jsPDF) {
                    showModal("Erro", "Biblioteca PDF (jsPDF) n√£o foi carregada.");
                    return;
                }

                const champ = championships.find(c => c.id === appState.currentChampionshipId);
                if (!champ || !activeChampionship) {
                    showModal("Erro", "Dados do campeonato n√£o carregados.");
                    return;
                }

                try {
                    const doc = new jsPDF();
                    let yPos = 22; // Posi√ß√£o vertical inicial

                    // 1. T√≠tulo
                    doc.setFontSize(18);
                    doc.text(champ.name, 105, yPos, { align: 'center' });
                    yPos += 10;

                    // 2. Tabela de Resultados Finais
                    doc.setFontSize(14);
                    doc.text("Resultados Finais", 14, yPos);
                    yPos += 7;

                    const finalResults = [];
                    // Ouro
                    const maxRoundGold = Math.max(...activeChampionship.goldBracket.map(m => m.round));
                    const goldFinal = activeChampionship.goldBracket.find(m => m.round === maxRoundGold);
                    if (goldFinal?.winner) {
                        finalResults.push(['ü•á Campe√µes Ouro', goldFinal.winner.name]);
                        const goldRunnerUp = goldFinal.pairs.find(p => p.id !== goldFinal.winner.id);
                        if (goldRunnerUp) finalResults.push(['Vice Ouro', goldRunnerUp.name]);
                    }
                    // Prata
                    const maxRoundSilver = Math.max(...activeChampionship.silverBracket.map(m => m.round));
                    const silverFinal = activeChampionship.silverBracket.find(m => m.round === maxRoundSilver);
                    if (silverFinal?.winner) {
                        finalResults.push(['ü•à Campe√µes Prata', silverFinal.winner.name]);
                        const silverRunnerUp = silverFinal.pairs.find(p => p.id !== silverFinal.winner.id);
                        if (silverRunnerUp) finalResults.push(['Vice Prata', silverRunnerUp.name]);
                    }

                    // Coveiro
                    const stats = getGlobalTournamentStats(activeChampionship);

                    if (stats.length > 0) {
                        const minGames = stats[0].gamesWon;
                        const coveiros = stats.filter(p => p.gamesWon === minGames);
                        finalResults.push(['üëª Coveiro(s)', coveiros.map(c => c.name).join(' / ')]);
                    }

                    doc.autoTable({
                        startY: yPos,
                        head: [['Pr√™mio', 'Dupla/Jogador']],
                        body: finalResults,
                        headStyles: { fillColor: [52, 73, 94], textColor: [255, 255, 255] },
                        styles: { textColor: [31, 41, 55] },
                        theme: 'striped',
                    });
                    yPos = doc.autoTable.previous.finalY + 10; // Atualiza a posi√ß√£o Y

                    // 3. Fase de Grupos (em nova p√°gina)
                    doc.addPage();
                    yPos = 22;
                    doc.setFontSize(18);
                    doc.text("Resultados da Fase de Grupos", 105, yPos, { align: 'center' });
                    yPos += 10;

                    activeChampionship.groups.forEach((group, index) => {
                        // Verifica se precisa de uma nova p√°gina
                        if (yPos > 240) {
                            doc.addPage();
                            yPos = 22;
                        }

                        doc.setFontSize(14);
                        doc.text(`Grupo ${index + 1}`, 14, yPos);
                        yPos += 7;

                        // Tabela de Jogos do Grupo
                        const matchesBody = group.matches.map(m => [
                            m.names[0],
                            `${m.score[0] === null ? '-' : m.score[0]} vs ${m.score[1] === null ? '-' : m.score[1]}`,
                            m.names[1]
                        ]);

                        doc.autoTable({
                            startY: yPos,
                            head: [['Dupla 1', 'Placar', 'Dupla 2']],
                            body: matchesBody,
                            headStyles: { fillColor: [8, 145, 178], textColor: [255, 255, 255] }, // Cor 'Mar' (cyan-600)
                            styles: { halign: 'center', textColor: [31, 41, 55] },
                            columnStyles: { 0: { halign: 'left' }, 2: { halign: 'right' } }
                        });
                        yPos = doc.autoTable.previous.finalY + 5;

                        // Tabela de Ranking do Grupo
                        const rankings = getRankings(group);
                        const rankingsBody = rankings.map((p, rIndex) => [
                            `${rIndex + 1}¬∫`,
                            p.name,
                            p.gamesWon
                        ]);

                        doc.autoTable({
                            startY: yPos,
                            head: [['Pos.', 'Jogador', 'Games Vencidos']],
                            body: rankingsBody,
                            theme: 'grid',
                            styles: { halign: 'center', fontSize: 9, textColor: [31, 41, 55] },
                            headStyles: { fillColor: [254, 243, 199], textColor: [75, 85, 99], fontSize: 10 }, // Cor 'Areia' (amber-100)
                        });
                        yPos = doc.autoTable.previous.finalY + 12;
                    });

                    // 4. Chaves (Mata-Mata)
                    if (yPos > 180) { // Se n√£o houver muito espa√ßo
                        doc.addPage();
                        yPos = 22;
                    } else {
                        yPos += 5; // Espa√ßamento
                    }

                    doc.setFontSize(18);
                    doc.text("Resultados do Mata-Mata", 105, yPos, { align: 'center' });
                    yPos += 10;

                    // Tabela S√©rie Ouro
                    doc.setFontSize(16);
                    doc.text("S√©rie Ouro ü•á", 14, yPos);
                    yPos += 7;
                    const goldBody = activeChampionship.goldBracket.map(m => {
                        const roundTitle = m.round === maxRoundGold ? 'Final'
                            : m.round === maxRoundGold - 1 ? 'Semi-Final'
                            : m.round === maxRoundGold - 2 ? 'Quartas' : `Rodada ${m.round}`;

                        // ALTERA√á√ÉO (BYE): Mostra "BYE" no PDF
                        const pair1Name = m.pairs[0]?.id === 'BYE' ? '--- BYE ---' : (m.pairs[0]?.name || '-');
                        const pair2Name = m.pairs[1]?.id === 'BYE' ? '--- BYE ---' : (m.pairs[1]?.name || '-');
                        const score = m.score[0] === null || m.score[1] === null 
                            ? ' - '
                            : `${m.score[0]} vs ${m.score[1]}`;

                        return [
                            roundTitle,
                            pair1Name,
                            score,
                            pair2Name
                        ];
                    });
                    doc.autoTable({
                        startY: yPos,
                        head: [['Rodada', 'Dupla 1', 'Placar', 'Dupla 2']],
                        body: goldBody,
                        headStyles: { fillColor: [249, 115, 22], textColor: [255, 255, 255] }, // Cor 'Acento' (orange-500)
                        styles: { halign: 'center', textColor: [31, 41, 55] },
                        columnStyles: { 1: { halign: 'left' }, 3: { halign: 'right' } }
                    });
                    yPos = doc.autoTable.previous.finalY + 10;

                    // Tabela S√©rie Prata
                    doc.setFontSize(16);
                    doc.text("S√©rie Prata ü•à", 14, yPos);
                    yPos += 7;
                    const silverBody = activeChampionship.silverBracket.map(m => {
                        const roundTitle = m.round === maxRoundSilver ? 'Final'
                            : m.round === maxRoundSilver - 1 ? 'Semi-Final'
                            : m.round === maxRoundSilver - 2 ? 'Quartas' : `Rodada ${m.round}`;

                        // ALTERA√á√ÉO (BYE): Mostra "BYE" no PDF
                        const pair1Name = m.pairs[0]?.id === 'BYE' ? '--- BYE ---' : (m.pairs[0]?.name || '-');
                        const pair2Name = m.pairs[1]?.id === 'BYE' ? '--- BYE ---' : (m.pairs[1]?.name || '-');
                        const score = m.score[0] === null || m.score[1] === null 
                            ? ' - '
                            : `${m.score[0]} vs ${m.score[1]}`;

                        return [
                            roundTitle,
                            pair1Name,
                            score,
                            pair2Name
                        ];
                    });
                    doc.autoTable({
                        startY: yPos,
                        head: [['Rodada', 'Dupla 1', 'Placar', 'Dupla 2']],
                        body: silverBody,
                        headStyles: { fillColor: [156, 163, 175], textColor: [31, 41, 55] }, // Prata
                        styles: { halign: 'center', textColor: [31, 41, 55] },
                        columnStyles: { 1: { halign: 'left' }, 3: { halign: 'right' } }
                    });

                    // 5. Salvar
                    doc.save(`resultados_${champ.name.toLowerCase().replace(/\s/g, '_')}.pdf`);

                } catch (error) {
                     console.error("Erro ao gerar PDF do campeonato:", error);
                    showModal("Erro", "N√£o foi poss√≠vel gerar o PDF. " + error.message);
                }
            };


            /* =============================================================================
               Inicializa√ß√£o do App (Autentica√ß√£o e Listeners Globais)
               ============================================================================= */

            const listenToGlobalPlayers = () => {
                unsubscribeGlobalPlayers(); 

                // Se nenhum ranking estiver selecionado (ex: durante o carregamento), n√£o faz nada
                if (!appState.currentRankingId) {
                    globalPlayers = [];
                    if(appState.currentView === 'globalRanking') render();
                    return;
                }

                // O caminho da cole√ß√£o agora √© din√¢mico
                const playersCollectionRef = collection(db, 'users', appState.userId, 'rankings', appState.currentRankingId, 'players');
                const q = query(playersCollectionRef);

                unsubscribeGlobalPlayers = onSnapshot(q, (querySnapshot) => {
                    globalPlayers = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    if (appState.currentView === 'globalRanking') {
                        render();
                    }
                    if (appState.currentView === 'championshipView' && activeChampionship?.status === 'registration') {
                        render();
                    }

                }, (error) => {
                    console.error(`Erro ao carregar ranking ${appState.currentRankingId}:`, error);
                    showModal("Erro", "N√£o foi poss√≠vel carregar o ranking selecionado.");
                    globalPlayers = [];
                    if(appState.currentView === 'globalRanking' || appState.currentView === 'championshipView') render();
                });
            };

            const listenToChampionships = () => {
                unsubscribeChampionships();
                // Usa o appState.userId (que ser√° o MESTRE_USER_ID)
                const champCollectionRef = collection(db, 'users', appState.userId, 'championships');
                const q = query(champCollectionRef);

                unsubscribeChampionships = onSnapshot(q, (querySnapshot) => {
                    championships = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    if (appState.currentView === 'championshipList') {
                        render();
                    }
                    if (appState.isTelaoMode && appState.currentView === 'telaoView') {
                        render();
                    }

                }, (error) => {
                    console.error("Erro ao carregar campeonatos:", error);
                    showModal("Erro", "N√£o foi poss√≠vel carregar o hist√≥rico de campeonatos.");
                });
            };

            const listenToActiveChampionship = (champId) => {
                unsubscribeActiveChampionship();
                // Usa o appState.userId (que ser√° o MESTRE_USER_ID)
                const champDataRef = doc(db, 'users', appState.userId, 'championships', champId, 'data', 'main');

                unsubscribeActiveChampionship = onSnapshot(champDataRef, (docSnap) => {
                    if (docSnap.exists()) {
                        activeChampionship = { id: docSnap.id, ...docSnap.data() };
                        render(); // Renderiza a tela atual (seja 'championshipView' ou 'telaoView')
                    } else {
                        showModal("Erro", "N√£o foi poss√≠vel carregar os dados deste campeonato. (O doc 'data/main' n√£o foi encontrado).");
                        if (!appState.isTelaoMode) navigateTo('championshipList');
                        else mainContent.innerHTML = `<h1 class="text-4xl text-rose-500 text-center p-10">Erro: Campeonato n√£o encontrado.</h1>`;
                    }
                }, (error) => {
                    console.error("Erro ao carregar campeonato ativo:", error);
                    showModal("Erro", "N√£o foi poss√≠vel carregar este campeonato. Verifique as regras do Firestore.");
                    if (!appState.isTelaoMode) navigateTo('championshipList');
                    else mainContent.innerHTML = `<h1 class="text-4xl text-rose-500 text-center p-10">Erro de conex√£o.</h1>`;
                });
            };

            const listenToRankingsList = () => {
                unsubscribeRankingsList();
                const rankingsDocRef = doc(db, 'users', appState.userId, 'app_data', 'rankings');

                unsubscribeRankingsList = onSnapshot(rankingsDocRef, async (docSnap) => {
                    let list = [];
                    if (docSnap.exists()) {
                        list = docSnap.data().list || [];
                    }

                    // Se for a primeira vez e a lista estiver vazia, cria um ranking padr√£o
                    if (list.length === 0) {
                        try {
                            const defaultRanking = { id: "ranking_geral", name: "Ranking Geral" };
                            await setDoc(rankingsDocRef, { list: [defaultRanking] });
                            allRankings = [defaultRanking];
                        } catch (error) {
                            console.error("Erro ao criar ranking padr√£o:", error);
                            showModal("Erro Cr√≠tico", "N√£o foi poss√≠vel inicializar a lista de rankings.");
                            return;
                        }
                    } else {
                        allRankings = list;
                    }

                    // Se nenhum ranking estiver selecionado no appState, OU se o ranking selecionado
                    // foi exclu√≠do, seleciona o primeiro da lista
                    const selectedRankingExists = allRankings.some(r => r.id === appState.currentRankingId);

                    if ((!appState.currentRankingId || !selectedRankingExists) && allRankings.length > 0) {
                        appState.currentRankingId = allRankings[0].id;
                    } else if (allRankings.length === 0) {
                        appState.currentRankingId = null; // Nenhum ranking existe
                    }

                    // Esta chamada √© crucial para que o `globalPlayers` seja preenchido na primeira carga
                    listenToGlobalPlayers();

                    // Re-renderiza a tela atual (pode ser a 'championshipList' ou 'globalRanking' que dependem dessa lista)
                    // N√£o chama o render() se estivermos no modo Tel√£o, pois o 'navigateTo' cuidar√° disso.
                    if (!appState.isTelaoMode) {
                        render();
                    }

                }, (error) => {
                    console.error("Erro ao carregar lista de rankings:", error);
                    showModal("Erro Cr√≠tico", "N√£o foi poss√≠vel carregar a lista de rankings.");
                });
            };

            // Ponto de entrada da aplica√ß√£o
            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Erro na autentica√ß√£o an√¥nima:", error);
                        let errorMessage = "N√£o foi poss√≠vel conectar ao Firebase. Verifique sua conex√£o.";
                        if (error.code === 'auth/configuration-not-found') {
                            errorMessage = "Erro de Autentica√ß√£o: O 'Login An√¥nimo' (Anonymous) n√£o est√° ATIVADO no seu painel do Firebase.";
                        }
                        showModal("Erro de Autentica√ß√£o", errorMessage);
                        return;
                    }
                }

                if (user && !appState.isAuthReady) {

                    const effectiveUserId = MESTRE_USER_ID; 

                    appState = { ...appState, userId: effectiveUserId, isAuthReady: true };
                    userIdFooter.textContent = effectiveUserId; // Mostra o ID Mestre no rodap√©

                    // L√≥gica de Roteamento (Normal vs Tel√£o)

                    // 1. Verifica os par√¢metros da URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const telaoChampId = urlParams.get('champId');

                    // 2. Inicia os listeners globais (necess√°rios para ambos os modos)
                    listenToChampionships();
                    listenToRankingsList(); // Esta fun√ß√£o vai chamar listenToGlobalPlayers()

                    if (urlParams.has('telao') && telaoChampId) {
                        // --- MODO TEL√ÉO ---
                        appState.isTelaoMode = true;
                        appState.isAdmin = false; // Tel√£o √© sempre visitante

                        // Adiciona estilos para a view limpa
                        const telaoStyles = document.createElement('style');
                        telaoStyles.innerHTML = `
                            body { background-color: #FFFAF0; } /* Fundo 'Areia' (amber-50) */
                            /* Ajusta o container para telas largas, mantendo um padding */
                            #app-container { max-width: 100%; padding: 1rem 2rem; }
                            header, footer { display: none !important; }
                        `;
                        document.head.appendChild(telaoStyles);

                        // Navega direto para o tel√£o
                        navigateTo('telaoView', telaoChampId);

                    } else {
                        // --- MODO NORMAL ---
                        appState.isTelaoMode = false;
                        navigateTo('login');
                    }
                }
            });

        </script>
    </body>
    </html>